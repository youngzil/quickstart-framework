1、前台任务和后台任务
2、前台任何和后台任务切换
3、nohup的使用：忽略SIGHUP信号并且在后台运行
4、如何kill后台任务



前台任务和后台任务

可以看出，”后台任务”与”前台任务”的本质区别只有一个：是否继承标准输入。

前台任务

前台任务是独占命令行窗口的任务，只有运行完了或者手动中止该任务，才能执行其他命令。比如我们开了一个jupyter notebook, 这个命令行就被独占了，无法执行其他命令，除非关闭了jupyter，命令行才可以输入其他命令。

后台任务

与前台任务相对应，后台任务在运行的时候，并不需要与用户交互，它们通常在不打扰用户其它工作的时候默默地执行。使shell可以继续响应用户的输入。后台任务继承当前会话的标准输出（stdout）和标准错误（stderr）。因此，后台任务的所有输出依然会同步地在命令行下显示。不再继承当前session的标准输入（stdin），你无法向这个任务输入指令了。如果它试图读取标准输入，就会暂停执行。



前台任何和后台任务切换

前台任务切换为后台任务
•启动时以后台任务启动，只需要在原来的命令后面加上&，启动的进程就会变为后台进程。
使用fg命令，将最后一个后台任务切换为前台任务
将正在运行的前台任务切换为后台任务，先ctrl+z将前台程序挂起, 然后执行bg命令让任务在后台继续执行

将一个程序变为后台任务并不能达到退出命令行后继续运行的效果，这是因为前面的那些前台和后台进程都算做是我们打开那个命令行的子进程，
如果我们关掉了命令行，系统将向这些子进程发送一个称为“SIGHUP”的信号，子进程收到信号后就会关闭。
因此，只需要让子进程忽略SIGHUP信号，就能实现关闭命令行窗口后程序继续运行了。



nohup的使用
nohup忽略SIGHUP信号，&是后台运行，合起来就是：忽略SIGHUP信号并且在后台运行

什么是nohup？
nohup 全称：no hang up（不挂起）。可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端

基本用法
nohup Command [Arg...] [ &] 最后的" &"：表示后台运行，不霸占交互命令行

如果不将 nohup 命令的输出重定向，输出将附加到当前目录的 nohup.out 文件中。
如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。
如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。

示例:
nohup jupyter notebook &
运行上面的命令，就会以后台任务运行jupyter,并且忽略挂起信号，即使关闭了命令行，我们依然可以正常访问 jupyter notebook。



如何kill后台任务
既然程序可以放在后台运行，那我们该如何关掉后台任务呢？要关闭后台任务，关键是要找到后台任务的进程ID, 然后通过kill -9 [id]来杀死进程。这里提供两种方法：

1、如果创建任务的终端窗口没有被关掉，在前台运行，先ctrl+z将前台程序挂起，可以使用jobs -l查看进程ID
2、如果命令行被关掉了，我们jobs命令是找不到我们的后台任务的，因为每个后台任务都是和命令行关联在一起，这里我们可以使用ps命令

PS：第一种方式感觉是脱了裤子放屁，多此一举，我为什么不直接ctrl+c或者关闭该Session，不就直接关闭了



