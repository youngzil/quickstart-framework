1、文件管理
2、文档编辑
3、文件传输
4、磁盘管理
5、磁盘维护
6、网络通讯
7、系统管理
8、系统设置
9、备份压缩
10、设备管理
11、查看Linux系统版本
12、linux安装软件的方式
13、linux下select/poll/epoll机制的比较
14、常用的命令
15、Linux 文件与目录管理
16、
17、
18、
19、
20、




---------------------------------------------------------------------------------------------------------------------

Linux 文件与目录管理


处理目录的常用命令

cd folder
pwd 显示路径
ls 显示全部的文件名称
ll 显示全部的文件详情
ls -al 显示隐藏的文件


接下来我们就来看几个常见的处理目录的命令吧：
ls: 列出目录
cd：切换目录，Change Directory的缩写
pwd：显示目前的目录，Print Working Directory 的缩写
mkdir：创建一个新的目录
rmdir：删除一个空的目录
cp: 复制文件或目录
rm: 移除文件或目录
mv: 移动文件与目录，或修改文件与目录的名称
你可以使用 man [命令] 来查看各个命令的使用文档，如 ：man cp。

ls
选项与参数：
-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)
-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)
-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)


-P ：显示出确实的路径，而非使用连结 (link) 路径。
pwd -P


mkdir (创建新目录)
如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。
语法：
mkdir [-mp] 目录名称
选项与参数：
-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～
-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！

我们给予 -m 711 来给予新的目录 drwx--x--x 的权限。如果没有加上 -m 来强制配置属性，系统会使用默认属性umask
mkdir -m 711 test2


cp (复制文件或目录)
cp 即拷贝文件和目录。
语法:
[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)
[root@www ~]# cp [options] source1 source2 source3 .... directory
选项与参数：
-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)
-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；
-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；
-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)
-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；
-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；
-r：递归持续复制，用於目录的复制行为；(常用)
-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；
-u：若 destination 比 source 旧才升级 destination ！

用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc
[root@www ~]# cp ~/.bashrc /tmp/bashrc
[root@www ~]# cp -i ~/.bashrc /tmp/bashrc
cp: overwrite `/tmp/bashrc'? n  <==n不覆盖，y为覆盖



rm (移除文件或目录)
语法：
 rm [-fir] 文件或目录
选项与参数：
-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；
-i ：互动模式，在删除前会询问使用者是否动作
-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！



mv (移动文件与目录，或修改名称)
语法：
[root@www ~]# mv [-fiu] source destination
[root@www ~]# mv [options] source1 source2 source3 .... directory
选项与参数：
-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；
-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！
-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)


---------------------------------------------------------------------------------------------------------------------
Linux 文件内容查看
Linux系统中使用以下命令来查看文件的内容：

cat  由第一行开始显示文件内容
tac  从最后一行开始显示，可以看出 tac 是 cat 的倒著写！
nl   显示的时候，顺道输出行号！
more 一页一页的显示文件内容
less 与 more 类似，但是比 more 更好的是，他可以往前翻页！
head 只看头几行
tail 只看尾巴几行
你可以使用 man [命令]来查看各个命令的使用文档，如 ：man cp。


cat
由第一行开始显示文件内容
语法：
cat [-AbEnTv]
选项与参数：
-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；
-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！
-E ：将结尾的断行字节 $ 显示出来；
-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；
-T ：将 [tab] 按键以 ^I 显示出来；
-v ：列出一些看不出来的特殊字符


nl
显示行号
语法：
nl [-bnw] 文件
选项与参数：
-b ：指定行号指定的方式，主要有两种：
-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；
-b t ：如果有空行，空的那一行不要列出行号(默认值)；
-n ：列出行号表示的方法，主要有三种：
-n ln ：行号在荧幕的最左方显示；
-n rn ：行号在自己栏位的最右方显示，且不加 0 ；
-n rz ：行号在自己栏位的最右方显示，且加 0 ；
-w ：行号栏位的占用的位数。


more
一页一页翻动

在 more 这个程序的运行过程中，你有几个按键可以按的：

空白键 (space)：代表向下翻一页；
Enter         ：代表向下翻『一行』；
/字串         ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；
:f            ：立刻显示出档名以及目前显示的行数；
q             ：代表立刻离开 more ，不再显示该文件内容。
b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。



less
一页一页翻动，与 more 类似，但是比 more 更好的是，他可以往前翻页！
less运行时可以输入的命令有：

空白键    ：向下翻动一页；
[pagedown]：向下翻动一页；
[pageup]  ：向上翻动一页；
/字串     ：向下搜寻『字串』的功能；
?字串     ：向上搜寻『字串』的功能；
n         ：重复前一个搜寻 (与 / 或 ? 有关！)
N         ：反向的重复前一个搜寻 (与 / 或 ? 有关！)
q         ：离开 less 这个程序；



head
取出文件前面几行
语法：
head [-n number] 文件 
选项与参数：
-n ：后面接数字，代表显示几行的意思

默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：
[root@www ~]# head -n 20 /etc/man.config



tail
取出文件后面几行
语法：
tail [-n number] 文件 
选项与参数：
-n ：后面接数字，代表显示几行的意思
-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测
[root@www ~]# tail /etc/man.config
# 默认的情况中，显示最后的十行！若要显示最后的 20 行，就得要这样：
[root@www ~]# tail -n 20 /etc/man.config


---------------------------------------------------------------------------------------------------------------------

1、 ls — List,ls会列举出当前工作目录的内容（文件或文件夹）。
2、mkdir — Make Directory，mkdir 用于新建一个新目录
3、pwd — Print Working Directory，显示当前工作目录
4、cd — Change Directory，切换文件路径，cd 将给定的文件夹（或目录）设置成当前工作目录。
5、rmdir— Remove Directory，删除给定的目录。
6、 rm— Remove，rm 会删除给定的文件
7、 cp— Copy，cp 命令对文件进行复制
8、 mv— Move
mv 命令对文件或文件夹进行移动，如果文件或文件夹存在于当前工作目录，还可以对文件或文件夹进行重命名。
9、cat— concatenate and print files
cat 用于在标准输出（监控器或屏幕）上查看文件内容

10. tail — print TAIL(from last)
ail 默认在标准输出上显示给定文件的最后10行内容，可以使用tail -n N 指定在标准输出上显示文件的最后N行内容。

11.less — print LESS
less 按页或按窗口打印文件内容。在查看包含大量文本数据的大文件时是非常有用和高效的。你可以使用Ctrl+F向前翻页，Ctrl+B向后翻页。


12.grep
grep 在给定的文件中搜寻指定的字符串。grep -i “” 在搜寻时会忽略字符串的大小写，而grep -r “” 则会在当前工作目录的文件中递归搜寻指定的字符串。
13.find
这个命令会在给定位置搜寻与条件匹配的文件。你可以使用find -name 的-name选项来进行区分大小写的搜寻，find -iname 来进行不区分大小写的搜寻。

14.tar
tar命令能创建、查看和提取tar压缩文件。tar -cvf 是创建对应压缩文件，tar -tvf 来查看对应压缩文件，tar -xvf 来提取对应压缩文件。

15. gzip
gzip 命令创建和提取gzip压缩文件，还可以用gzip -d 来提取压缩文件。


16. unzip
unzip 对gzip文档进行解压。在解压之前，可以使用unzip -l 命令查看文件内容。




17.help
help会在终端列出所有可用的命令,可以使用任何命令的-h或-help选项来查看该命令的具体用法。图就省略啦，会有详细列表显示出来的。
18.whatis — What is this command
whatis 会用单行来描述给定的命令，就是解释当前命令。



19.exit
exit用于结束当前的终端会话。



20.ping
ping 通过发送数据包ping远程主机(服务器)，常用与检测网络连接和服务器状态。



21.who — Who Is logged in
who能列出当前登录的用户名。


22.su — Switch User
su 用于切换不同的用户。即使没有使用密码，超级用户也能切换到其它用户。



23.uname
uname会显示出关于系统的重要信息，如内核名称、主机名、内核版本、处理机类型等等，使用uname -a可以查看所有信息。


24.df — Disk space Free
df查看文件系统中磁盘的使用情况–硬盘已用和可用的存储空间以及其它存储设备。你可以使用df -h将结果以人类可读的方式显示。


25.ps — ProcesseS
ps显示系统的运行进程。


26.top — Top processes
top命令会默认按照CPU的占用情况，显示占用量较大的进程,可以使用top -u 查看某个用户的CPU使用排名情况。


27. shutdown
shutdown用于关闭计算机，而shutdown -r用于重启计算机。这个我就不试了......





参考
https://gywbd.github.io/posts/2014/8/50-linux-commands.html




---------------------------------------------------------------------------------------------------------------------

一、查看Linux内核版本命令（两种方法）：
1、cat /proc/version
2、uname -a


二、查看Linux系统版本的命令（3种方法）： 
1、lsb_release -a，即可列出所有版本信息：这个命令适用于所有的Linux发行版，包括Redhat、SuSE、Debian…等发行版。
2、cat /etc/redhat-release，这种方法只适合Redhat系的Linux：
3、cat /etc/issue，此命令也适用于所有的Linux发行版。


---------------------------------------------------------------------------------------------------------------------
linux安装软件的方式

因为linux安装软件的方式比较多，所以没有一个通用的办法能查到某些软件是否安装了。总结起来就是这样几类：
1、rpm包安装的，可以用rpm -qa看到，如果要查找某软件包是否安装，用 rpm -qa | grep “软件或者包的名字”。
[root@hexuweb102 ~] rpm -qa | grep ruby
2、以deb包安装的，可以用dpkg -l能看到。如果是查找指定软件包，用dpkg -l | grep “软件或者包的名字”；
[root@hexuweb102~]dpkg-l|grepruby
3、yum方法安装的，可以用yum list installed查找，如果是查找指定包，命令后加 | grep “软件名或者包名”；
[root@hexuweb102 ~] yum list installed | grep ruby
4、如果是以源码包自己编译安装的，例如.tar.gz或者tar.bz2形式的，这个只能看可执行文件是否存在了，
上面两种方法都看不到这种源码形式安装的包。如果是以root用户安装的，可执行程序通常都在/sbin:/usr/bin目录下。
说明：其中rpm yum 是Redhat系linux的软件包管理命令，dpkg是debian系列的软件包管理命令


---------------------------------------------------------------------------------------------------------------------

linux下select/poll/epoll机制的比较


 一个进程在 linux 上能打开的文件句柄数是有限的，因为内核用 16位的 short 来表示文件句柄数，那么最大值是不是 65536 呢？
而accept一个socket连接，也是要在系统本地创建一个文件的，就占用了这个 socket server 进程的一个文件句柄，这样算下来，一个进程是不是理论上最多就能保持 65536个长连接呢
（1024 以下一般保留）？
一个 jvm 上启动一个java的socket server 应该算是一个系统进程吧？那么这个进程是怎么维持 65536 以上的长连接的呢？
 
 首先说一下 服务器是只监听一个端口，所有的客户端连接，都是连接到服务器的同一个端口上的。也就是说服务器只是用了一个端口。就比如Http服务器。默认只用了80端口。
这是解答一些人的这个疑惑。
下面来回答你的问题
nio 在linux上使用的是epoll ，epoll支持在一个进程中打开的FD是操作系统最大文件句柄数，而不是你所说的16位short表示的文件句柄。 而 select模型 单进程打开的FD是受限的 
select模型默认FD是1024 。操作系统最大文件句柄数跟内存有关，1GB内存的机器上，大概是10万个句柄左右。可以通过cat /proc/sys/fs/file-max 查看
这个可以在Netty权威指南第二版的第七页看到。
我ubuntu虚拟机，2G内存。结果是 200496


(1)select==>时间复杂度O(n)
(2)poll==>时间复杂度O(n)
(3)epoll==>时间复杂度O(1)

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，
而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。  


select：

select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：
1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。
      一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.
2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：
       当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。
3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大


poll：

poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。

它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：
1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。                   
2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。


epoll的优点：

1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；
2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；
即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。
3、 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销。


select、poll、epoll 区别总结：
1、支持一个进程所能打开的最大连接数
    select：单个进程所能打开的最大连接数有FD_SETSIZE宏定义，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上FD_SETSIZE为3264）
    poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的
    epoll 虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接
2、FD剧增后带来的IO效率问题
    select、poll：因为每次调用时都会对连接进行线性遍历，所以随着FD的增加会造成遍历速度慢的“线性下降性能问题”。
    epoll：因为epoll内核中实现是根据每个fd上的callback函数来实现的，只有活跃的socket才会主动调用callback，所以在活跃socket较少的情况下，使用epoll没有前面两者的线性下降的性能问题，但是所有socket都很活跃的情况下，可能会有性能问题。
3、 消息传递方式
  select、poll：内核需要将消息传递到用户空间，都需要内核拷贝动作
  epoll通过内核和用户空间共享一块内存来实现的。   

总结：
综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。
1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善 


参考
https://www.cnblogs.com/aspirant/p/9166944.html

---------------------------------------------------------------------------------------------------------------------

