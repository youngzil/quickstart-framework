- [PS命令格式](#PS命令格式)
- [LINUX进程号PID为1的进程](#LINUX进程号PID为1的进程)




---------------------------------------------------------------------------------------------------------------------

## PS命令格式

静态进程查看命令（ps）、动态进程查看命令（top）和查看进程树命令(pstree)


ps命令格式：  
- ps -aux     查看系统所有进程
- ps -lA        查看所有系统的数据
- ps axjf       连通部分进程树状态
- ps -l：仅查看自己的bash相关进程


参数：
- -A ：所有的进程均显示出来，与 -e 具有同样的效用；
- -a ： 显示现行终端机下的所有进程，包括其他用户的进程；
- -u ：以用户为主的进程状态 ；
- x ：通常与 a 这个参数一起使用，可列出较完整信息。

输出格式规划：
- l ：较长、较详细的将该PID 的的信息列出；
- j ：工作的格式 (jobs format)
- -f ：做一个更为完整的输出。


Head标头：

USER    用户名

UID    用户ID（User ID）

PID    进程ID（Process ID）

PPID    父进程的进程ID（Parent Process id）

SID    会话ID（Session id）

%CPU    进程的cpu占用率

%MEM    进程的内存占用率

VSZ    进程所使用的虚存的大小（Virtual Size）

RSS    进程使用的驻留集大小或者是实际内存的大小，Kbytes字节。

TTY    与进程关联的终端（tty）

STAT    进程的状态：进程状态使用字符表示的（STAT的状态码）

R 运行    Runnable (on run queue)            正在运行或在运行队列中等待。

S 睡眠    Sleeping                休眠中, 受阻, 在等待某个条件的形成或接受到信号。

I 空闲    Idle

Z 僵死    Zombie（a defunct process)        进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放。

D 不可中断    Uninterruptible sleep (ususally IO)    收到信号不唤醒和不可运行, 进程必须等待直到有中断发生。

T 终止    Terminate                进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行。

P 等待交换页

W 无驻留页    has no resident pages        没有足够的记忆体分页可分配。

X 死掉的进程

< 高优先级进程                    高优先序的进程

N 低优先    级进程                    低优先序的进程

L 内存锁页    Lock                有记忆体分页分配并缩在记忆体内

s 进程的领导者（在它之下有子进程）；

l 多进程的（使用 CLONE_THREAD, 类似 NPTL pthreads）

+ 位于后台的进程组 

START    进程启动时间和日期

TIME    进程使用的总cpu时间

COMMAND    正在执行的命令行命令

NI    优先级(Nice)

PRI    进程优先级编号(Priority)

WCHAN    进程正在睡眠的内核函数名称；该函数的名称是从/root/system.map文件中获得的。

FLAGS    与进程相关的数字标识




[Linux PS命令详解](https://www.cnblogs.com/hunttown/p/5452253.html)  
[Linux：PS命令详解与使用](https://www.cnblogs.com/linghu-java/p/9060531.html)  
[Linux查看系统进程信息命令总结 （ps/top/pstree）](https://blog.csdn.net/longerzone/article/details/8015941)  


---------------------------------------------------------------------------------------------------------------------
## LINUX进程号PID为1的进程

Linux 操作系统的启动首先从 BIOS 开始，然后由 Boot Loader 载入内核，并初始化内核。  
内核初始化的最后一步就是启动 init 进程。这个进程是系统的第一个进程，PID 为 1，又叫超级进程，也叫根进程。它负责产生其他所有用户进程。所有的进程都会被挂在这个进程下，如果这个进程退出了，那么所有的进程都被 kill 。  
如果一个子进程的父进程退了，那么这个子进程会被挂到 PID 1 下面。（注：PID 0 是内核的一部分，主要用于内进换页，参看：Process identifier）  



### 普通进程
普通进程，父进程不主动去回收子进程的资源。  
一个子进程在其父进程还没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。产生僵尸进程的原因：
1. 子进程结束后向父进程发出SIGCHLD信号，父进程默认忽略了它；
2. 父进程没有调用wait()或waitpid()函数来等待子进程的结束；

处理办法：把父进程杀掉，僵尸进程会变成孤儿进程，然后过继给1号进程，而1号进程会扫描名下子进程，把 Z 状态进程回收；

这时候僵尸进程已经退出了，只保留了task_struct结构体，所以发信号（-9等信号）去处理僵尸进程是无效的；



### ppid=1的进程
通过对普通僵尸进程的分析，这样看起来好像 父进程为1号进程的进程 不会成为僵尸进程了，因为1号进程都会时刻扫描其子进程的状态。发现是 僵尸进程就会马上去释放它的资源；


但是，父进程为1号进程的进程  其实也是有可能成为僵尸进程的。下面说几种情况：
1. 进程还在被其它进程使用，退出；
2. 进程的子线程还在执行任务，但主线程已经死掉了（可能主线程已经被杀了，systemd停止服务时会发SIGTERM信号）；
3. 进程阻塞在某一IO请求上,这时控制权已交到内核手上,这时如果子进程被KILL掉, 那么就成为父进程ID为1的僵尸进程,这个进程不会退出,会一直阻塞直到IO请求被满足；


那当出现父进程为1号进程的僵尸进程时，需要分析时，可以考虑上面几种情况；
1. 查看下当前这个僵尸进程是否被其他进程使用，比如：被跟踪，调试之类的；
2. 用ps -T -p <pid> 查看下这个僵尸进程的主线程是否退出；
3. 用strace 跟踪下这个僵尸进程看看是否有io在等待，或者查看下载僵尸之前是否有io类的操作发生；


其实ppid=1的僵尸进程可以不用去管他，因为它迟早会被1号进程回收的（如果有很多僵尸进程除外）。  
并且绝大部分ppid=1的僵尸进程是暂时的：
1. 当进程被跟踪调试完，则会自动被回收掉的；
2. 其他子线程组的线程执行完后会自动退出，僵尸进程会被回收；
3. 这个可能会一直挂着，如果阻塞的io永远没有到达；

总之，遇到少量的僵尸进程，可以不需要特意的去处理，只需要查看下根源，看看是否有潜在的bug就可以；

（记得有种攻击方法就是创建很多僵尸进程，把进程列表占满，导致系统不能再创建进程）



父进程为1号进程
[LINUX PID 1 和 SYSTEMD](https://coolshell.cn/articles/17998.html)  
[父进程为1号进程（ppid=1）的僵尸进程处理和分析](https://blog.csdn.net/YuZhiHui_No1/article/details/53011390)  


---------------------------------------------------------------------------------------------------------------------







