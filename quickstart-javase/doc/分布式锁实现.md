在同一个jvm进程中时，可以使用JUC提供的一些锁来解决多个线程竞争同一个共享资源时候的线程安全问题，但是当多个不同jvm进程中的线程共同竞争同一个共享资源时候，juc包的锁就无能无力了，这时候就需要分布式锁了。常见的有使用zk的最小版本，redis的set函数，数据库锁来实现


代码org.quickstart.javase.distributed.lock
使用数据库悲观锁实现不可重入的分布式锁
使用Redis单实例实现不可重入的分布式锁
使用zookeeper序列节点实现不可重入的分布式锁


DB数据库：
使用select * from lock where uid = 1 for update的拍他锁，设置不自动提交，先执行该SQL，然后执行业务，然后提交



Redis：
使用SetNX，设置过期时间，过期时间太小会出现业务没有做完锁就释放了
还可以设置超过多少次没有获取就等待，随机生成一个等待时间，等时间到后在进行重试，升级成重量级锁


使用zookeeper实现分布式锁
首先我们先来看看使用zk实现分布式锁的原理，在zk中是使用文件目录的格式存放节点内容，其中节点类型分为：
持久节点（PERSISTENT ）：节点创建后，一直存在，直到主动删除了该节点。
临时节点（EPHEMERAL）：生命周期和客户端会话绑定，一旦客户端会话失效，这个节点就会自动删除。
序列节点（SEQUENTIAL ）：多个线程创建同一个顺序节点时候，每个线程会得到一个带有编号的节点，节点编号是递增不重复的，如下图：

如上图，三个线程分别创建路径为/root/node的节点，可知在zk服务器端会在root下存在三个node节点，并且器编号唯一递增。
具体在节点创建过程中，可以混合使用，比如临时顺序节点（EPHEMERAL_SEQUENTIAL），这里我们就使用临时顺序节点来实现分布式锁。
分布式锁实现：
创建临时顺序节点,比如/root/node，假设返回结果为nodeId。
获取/root下所有孩子节点，用自己创建的nodeId的序号与所有子节点比较，看看自己是不是编号最小的。如果是最小的则就相当于获取到了锁，如果自己不是最小的，则从所有子节点里面获取比自己次小的一个节点，然后设置监听该节点的事件，然后挂起当前线程。
当最小编号的线程获取锁，处理完业务后删除自己对应的nodeId，删除后会激活比自己大一号的节点的线程从阻塞变为运行态，被激活的线程应该就是当前node序列号最小的了，然后就会获取到锁。





