Java中new对象的过程问题


🎈请解释对象的创建过程？
🎈DCL(Double-Check Locking)需不需要volatile？
🎈请解释对象在内存中的存储布局？
🎈对象头具体包括什么？
🎈JVM如何定位一个对象？
🎈对象在内存中如何分配？栈上？堆上？
🎈一个Object对象在内存中占用多少字节？




---------------------------------------------------------------------------------------------------------------------

🎈请解释对象的创建过程？
🎈DCL(Double-Check Locking)需不需要volatile？
    需要
🎈请解释对象在内存中的存储布局？
    第一部分：对象头
    第二部分：实例数据
    第三部分：对齐填充
🎈对象头具体包括什么？
    1、markword：用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁等。这部分数据长度在32位机器和64位机器虚拟机中分别为4字节和8字节（64位的JVM为了节约内存可以使用选项+UseCompressedOops开启指针压缩，开启该选项后，占用字节数降为4字节）；
    2、类型指针：即对象指向它的类元数据（保存在方法区）的指针，虚拟机通过这个指针来确定这个对象属于哪个类的实例，指针占用4个字节（64位机器占8个字节）；
    3、数组长度（只有数组对象才有）：如果是 Java 数组，对象头必须有一块用于记录数组长度的数据，用4个字节int来记录数组长度；
🎈JVM如何定位一个对象？
    由于引用类型数据（reference）在 Java虚拟机中只规定了一个指向对象的引用，但没定义该引用应该通过何种方式去定位、访问堆中的对象的具体位置
    所以对象访问方式取决于虚拟机实现。目前主流的对象访问方式有两种：
    1、使用句柄
    2、使用直接指针
🎈对象在内存中如何分配？栈上？堆上？
    java中内存主要包含4块，即heap(堆内存)、stack(栈内存)、data segment(静态变量或是常量存放区)、codesegment(方法区). 
    堆内存中存放的是new出的对象，new出的对象只包含成员变量。 
    栈内存中：存放的是局部成员变量。对于基本的数据类型存放的是基本变量的值，而对于对象变量，存放的是堆内存的地址。 
    静态、常量区：存放的是静态变量(类变量)或是常量。 
    方法区：存放的是对象的方法。因此即使new出多个对象也是只是存在一个方法。 
🎈一个Object对象在内存中占用多少字节？
    内存布局中的三块区域的大小加到一起





参考
https://blog.csdn.net/ljc1026774829/article/details/99336730
https://www.jianshu.com/p/1952061502d0
https://blog.csdn.net/liupeifeng3514/article/details/79111651
https://blog.csdn.net/u014520047/article/details/81940447



---------------------------------------------------------------------------------------------------------------------
Java中new对象的过程问题


java在new一个对象的时候，会先查看对象所属的类有没有被加载到内存，如果没有的话，就会先通过类的全限定名来加载。
加载并初始化类完成后，再进行对象的创建工作。

我们先假设是第一次使用该类，这样的话new一个对象就可以分为两个过程：加载并初始化类和创建对象。



一、类加载过程（第一次使用该类）
1、加载
2、验证：格式验证、语义验证、操作验证
格式验证：验证是否符合class文件规范
语义验证：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）
操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）

3、准备:为类中的所有静态变量分配内存空间，并为其设置一个初始值
为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）
被final修饰的static变量（常量），会直接赋值；

4、解析:将常量池中的符号引用转为直接引用、解析需要静态绑定的内容
将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。
解析需要静态绑定的内容。  // 所有不会被重写的方法和域都会被静态绑定

　　以上2、3、4三个阶段又合称为链接阶段，链接阶段要做的是将加载到JVM中的二进制字节流的类数据信息合并到JVM的运行时状态中。

5、初始化（先父后子）：为静态变量赋值、执行static代码块
4.1 为静态变量赋值
4.2 执行static代码块



二、创建对象
1、在堆区分配对象需要的内存
　　分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量

2、对所有实例变量赋默认值
　　将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值

3、执行实例初始化代码
　　初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法

4、如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它
 

需要注意的是，每个子类对象持有父类对象的引用，可在内部通过super关键字来调用父类对象，但在外部不可访问



参考
https://blog.csdn.net/weixin_45082647/article/details/105520394
https://www.cnblogs.com/JackPn/p/9386182.html

---------------------------------------------------------------------------------------------------------------------
