1、JVM 与 Linux 的内存关系详解.md    
2、JVM 和JMM的区别   
JMM总结
讲一下jmm，为何这样设计
并发编程，为了保证数据的安全，需要满足以下三个特性
什么是线程安全
举三个例子分别描述 jmm的三个特性「原子性、有序性、可见性」导致的线程安全问题


as-if-serial语义
happens-before定义
as-if-serial VS happens-before


---------------------------------------------------------------------------------------------------------------------
1、JVM 与 Linux 的内存关系详解.md    

##一、Linux与进程内存模型

JVM以一个进程（Process）的身份运行在Linux系统上，了解Linux与进程的内存关系，是理解JVM与Linux内存的关系的基础。   

从硬件上看，Linux系统的内存空间由两个部分构成：物理内存和SWAP（位于磁盘）。  
物理内存是Linux活动时使用的主要内存区域； 
当物理内存不够使用时，Linux会把一部分暂时不用的内存数据放到磁盘上的SWAP中去，以便腾出更多的可用内存空间；   
而当需要使用位于SWAP的数据时，必须 先将其换回到内存中。  


从Linux系统上看，除了引导系统的BIN区，整个内存空间主要被分成两个部分：
内核内存（Kernel space）、
用户内存（User space）。 
内核内存是Linux自身使用的内存空间，主要提供给程序调度、内存分配、连接硬件资源等程序逻辑使用。   
用户内存是提供给各个进程主要空间，Linux给各个进程提供相同的虚拟内存空间；这使得进程之间相互独立，互不干扰。    
实现的方法是采用虚拟内存技术：给每一个进程一定虚拟内存空间，而只有当虚拟内存实 际被使用时，才分配物理内存。  

从进程的角度来看，进程能直接访问的用户内存（虚拟内存空间）被划分为5个部分：代码区、数据区、堆区、栈区、未使用区。   

代码区中存放应用程序的机器代码，运行过程中代码不能被修改，具有只读和固定大小的特点。      
数据区中存放了应用程序中的全局数据，静态数据和一些常量字符串等，其大小也是固定的。       
堆是运行时程序动态申请的空间，属于程序运行时直接申请、释放的内存资源。     
栈区用来存放函数的传入参数、临时变量，以及返回地址等数据。       
未使用区是分配新内 存空间的预备区域。     


##二、进程与JVM内存空间
JVM本质就是一个进程，因此其内存空间（也称之为运行时数据区，注意与JMM的区别）也有进程的一般特点。深入浅出 Java 中 JVM 内存管理，这篇参考下。
但是，JVM又不是一个普通的进程，其在内存空间上有许多崭新的特点，主要原因有两 个：

- JVM将许多本来属于操作系统管理范畴的东西，移植到了JVM内部，目的在于减少系统调用的次数；
- Java NIO，目的在于减少用于读写IO的系统调用的开销。JVM进程与普通进程内存模型比较如下图:


1.用户内存  

2.内核内存
应用程序通常不直接和内核内存打交道，内核内存由操作系统进行管理和使用；  
不过随着Linux对性能的关注及改进，一些新的特性使得应用程序可以使 用内核内存，或者是映射到内核空间。    
Java NIO正是在这种背景下诞生的，其充分利用了Linux系统的新特性，提升了Java程序的IO性能。



参考      
https://juejin.im/post/5cceea7c6fb9a0322279307b     
https://blog.csdn.net/hxcaifly/article/details/82563269     
---------------------------------------------------------------------------------------------------------------------

2、JVM 和JMM的区别  

首先从定义上看
- JVM (Java Virtual Machine)Java虚拟机模型 主要描述的是Java虚拟机内部的结构以及各个结构之间的关系。
- JMM(Java Memory Model) Java内存模型 主要规定了一些内存和线程之间的关系


其次从内存结构上看
- JVM内存结构：PC程序计数器，虚拟机栈，方法栈，堆，方法区
- 主内存、工作内存（线程本地内存）


Java内存模型(Java Memory Model，JMM)JMM主要是为了规定了线程和内存之间的一些关系。     
根据JMM的设计，系统存在一个主内存(Main Memory)，Java中所有变量都储存在主存中，对于所有线程都是共享的。   
每条线程都有自己的工作内存(Working Memory)，工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是在工作内存中进行，线程之间无法相互直接访问，变量传递均需要通过主存完成。



总结：     
jmm中的主内存、工作内存与jvm中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，
如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。   
从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。

JMM总结
JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。



讲一下jmm，为何这样设计

java memeory model ，java 内存模型，设计的目的是屏蔽掉各种硬件和操作系统之间的差异性，实现让 Java 在各种平台下都能能到一致的并发效果。
jmm 中，分为主内存和工作内存，其中每个线程拥有自己的工作内存，而主内存是所有线程共享的。

Java内存模型的两个关键概念：可见性（Visibility）和可排序性（Ordering）



为何要有工作内存，有了主内存和工作内存不是更麻烦啊，要不断的复制移动数据，为何不能直接对主内存操作？【就是上面两点：高效并发】
这就跟为何要提出寄存器和缓存一样的道理，如果所有的操作都在内存中完成，那速度实在是太慢了，只有工作在寄存器和缓存中，速度才能让人满意，而这里的主内存就类比为内存，工作内存就类比为寄存器和缓存。

分为主内存、工作内存，为什么这么设计：
1、高效：高速缓存的作用，多次修改，一次同步到主内存
2、并发：除了synchronized和volatile等



并发编程，为了保证数据的安全，需要满足以下三个特性：
原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
有序性即程序执行的顺序按照代码的先后顺序执行。

有没有发现，缓存一致性问题其实就是可见性问题。
而处理器优化是可以导致原子性问题的。
指令重排即会导致有序性问题。



什么是线程安全 
多个线程访问一个对象，无需考虑环境和额外同步，调用这个对象的行为就能得到正确的答案，就说明这个对象是线程安全的。

举三个例子分别描述 jmm的三个特性「原子性、有序性、可见性」导致的线程安全问题
1、不遵循原子性：volatile 变量的自加，复合操作，导致线程不安全；
2、不遵循有序性：比如共享变量，多个线程同时访问，不按序，每个都拷贝一份到自己的工作内存，必然会导致线程不安全；
3、不遵循可见性：普通变量，跟有序性一样的例子，每个都从主内存拷贝一份变量的副本到工作内存，必然会导致线程不安全。




as-if-serial语义
as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。编译器，runtime和处理器都必须遵守as-if-serial语义。as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。比如上面计算圆面积的代码，在单线程中，会让人感觉代码是一行一行顺序执行上，实际上A,B两行不存在数据依赖性可能会进行重排序，即A，B不是顺序执行的。as-if-serial语义使程序员不必担心单线程中重排序的问题干扰他们，也无需担心内存可见性问题。


happens-before定义
JSR-133使用happens-before的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。
因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：
1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。

上面的1）是JMM对程序员的承诺。从程序员的角度来说，可以这样理解happens-before关系：如果A happens-before B，那么Java内存模型将向程序员保证——A操作的结果将对B可见，且A的执行顺序排在B之前。注意，这只是Java内存模型向程序员做出的保证！

上面的2）是JMM对编译器和处理器重排序的约束原则。正如前面所言，JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before关系本质上和as-if-serial语义是一回事。


比较:
as-if-serial   VS   happens-before
1、as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。
2、as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。
3、as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。



参考  
https://www.jianshu.com/p/797129612bed
https://juejin.im/post/5d67d248f265da03ea5a9198
https://blog.csdn.net/zhaomengszu/article/details/80270696
https://www.cnblogs.com/huxuer/p/9066269.html   
https://blog.csdn.net/longfulong/article/details/78790955


