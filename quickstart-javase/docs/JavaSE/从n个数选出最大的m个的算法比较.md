n×m遍扫描 
【算法基本描述】n×m遍扫描 
【算法思想】每次都扫描一遍数组，取出最大元素，这样扫描m遍就能得到m个最大的数 
【算法复杂度】O(nm)

排序后取最大m个数 
【算法基本描述】对n个数排序，对拍完序后的序列取m个最大的数 
【算法复杂度】视排序的复杂度，一般为O(nlogn)或O(n^2)

计数排序（bitmap） 
一次遍历数组记录出现次数O(n)，倒过来变量计算m个。

最小堆 
【算法基本描述】一遍扫描+最小堆 
【算法复杂度】O(nlogm) 遍历O(n) 最小堆O(logm) 
【其他】如果要求n个数中取最小的m个，只要把算法反一下即可 
【算法伪代码】

00-建立一个最小堆（优先队列），最小堆的大小控制在m之内
01-for 每个数：
02-----if 这个数比最小堆的堆顶元素大：
03---------弹出最小堆的最小元素
04---------把这个数插入到最小堆
05-最小堆中的m个元素就是所要求的元素
06-其中最小堆的作用就是保持里面始终有m个最大元素，且m个元素中最小的元素在堆顶。

---------------------

本文来自 wanhf11 的CSDN 博客 ，全文地址请点击：https://blog.csdn.net/qq_17612199/article/details/51203518?utm_source=copy 