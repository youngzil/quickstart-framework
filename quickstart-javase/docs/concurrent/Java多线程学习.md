- [多线程编程的几个概念](#多线程编程的几个概念)
- [Linux进程间通信方式](#Linux进程间通信方式)
- [Java线程的创建和分类](#Java线程的创建和分类)
- [Unsafe类的使用](#Unsafe类的使用)
- [Java线程的5种状态及切换](#Java线程的5种状态及切换)
- [多线程，到底该设置多少个线程？](#多线程，到底该设置多少个线程？)
- [线程间的通信、同步方式与进程间通信方式](#线程间的通信、同步方式与进程间通信方式)
- [引起线程切换的几种方式](#引起线程切换的几种方式)
- [线程安全性定义、控制](#线程安全性定义、控制)



2、java进程和Linux线程的关系

[Java线程有哪些状态，有哪些锁，各种锁的区别](https://blog.csdn.net/songzi1228/article/details/100535928)

---------------------------------------------------------------------------------------------------------------------
## 多线程编程的几个概念


在多线程编程时，你需要了解以下几个概念：
1. 线程同步：synchronized关键字、重入锁ReentrantLock类、特殊域变量(volatile)、CAS变量、并发工具类（信号量）、线程变量ThreadLocal  
    线程同步（两种锁、特殊变量volatile、线程变量ThreadLocal、并发工具类）
2. 线程间通信：wait+notify/notifyAll、Condition中await+signal/signalAll、锁机制、共享对象（内存或文件、信号量）、Exchanger数据交换
3. 线程死锁：
	死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。
	死锁产生的必要条件：互斥、不可剥夺、请求保持、循环等待，
	解决：加锁顺序、加锁时限、死锁检测
4. 线程控制：挂起、停止和恢复：线程方法、锁（synchronized关键字、重入锁ReentrantLock类）、wait、Condition中的await
//挂起线程
t.suspend();
//恢复线程
t.resume();


参考  
[Java多线程学习（总结很详细！！！）](https://www.cnblogs.com/yjd_hycf_space/p/7526608.html)  
[多线程死锁的产生以及如何避免死锁](https://blog.csdn.net/ls5718/article/details/51896159)

---------------------------------------------------------------------------------------------------------------------
## Linux进程间通信方式

在java中主要的通信方式有以下几种： 
1、socket通信 
2、同步：RMI（远程方法调用） 或者 RPC
3、异步：消息队列（第三方框架Kafka，ActiveMQ等） 
4、共享对象：内存、文件共享，文件锁（一个进程向文件中写文件，一个负责读文件） 
5、JMX（java management extensions）java扩展管理 
6、信号 、信号量


在操作系统中进程和线程的区别：
　　进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）
　　线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）
　　线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。
　　多进程是指操作系统能同时运行多个任务（程序）。
　　多线程是指在同一程序中有多个顺序流在执行。

---------------------------------------------------------------------------------------------------------------------
## Unsafe类的使用

Unsafe类：
https://www.cnblogs.com/pkufork/p/java_unsafe.html
https://www.cnblogs.com/mickole/articles/3757278.html
http://www.importnew.com/14511.html
https://blog.csdn.net/zhxdick/article/details/52003123

队列的超时等待(如线程池中的)：UNSAFE.park(false, nanos)、unpark，线程--》队列的poll超时--》Condition的await---》LockSupport.park---UNSAFE.park
NIO的DirectByteBuffer内存分配：unsafe.allocateMemory(size)，freeMemory(long)
原子类的CAS方法：unsafe.compareAndSwapInt方法、unsafe.compareAndSwapLong

- 1、通过Unsafe类可以分配内存，可以释放内存；
类中提供的3个本地方法allocateMemory、reallocateMemory、freeMemory分别用于分配内存，扩充内存和释放内存，与C语言中的3个方法对应。
- 2、CAS操作
是通过compareAndSwapXXX方法实现的
- 3、挂起与恢复
将一个线程进行挂起是通过park方法实现的，调用 park后，线程将一直阻塞直到超时或者中断等条件出现。unpark可以终止一个挂起的线程，使其恢复正常。整个并发框架中对线程的挂起操作被封装在 LockSupport类中，LockSupport类中有各种版本pack方法，但最终都调用了Unsafe.park()方法。
- 4、数组操作。
这部分包括了arrayBaseOffset（获取数组第一个元素的偏移地址）、arrayIndexScale（获取数组中元素的增量地址）等方法。arrayBaseOffset与arrayIndexScale配合起来使用，就可以定位数组中每个元素在内存中的位置。  
由于Java的数组最大值为Integer.MAX_VALUE，使用Unsafe类的内存分配方法可以实现超大数组。实际上这样的数据就可以认为是C数组，因此需要注意在合适的时间释放内存。



---------------------------------------------------------------------------------------------------------------------
## Java线程的5种状态及切换

Java线程的5种状态及切换(透彻讲解)
https://www.cnblogs.com/nwnu-daizh/p/8036156.html
http://blog.csdn.net/pange1991/article/details/53860651


新建-->就绪-->运行-->死亡（start(),获取cpu时间片,run/main结束）
运行-->阻塞-->就绪-->运行（sleep、t2.join、等用户输入，3中阻塞条件结束，获取cpu时间片）
运行-->等待队列-->锁池队列-->就绪（wait()+notify/notifyAll、synchronized(obj) ）
运行-->就绪（yield()、时间片用完）

![线程状态转换](../images/threadstatuschange.png "ReferencePicture")

在调用sleep()方法的过程中，线程不会释放对象锁。  
而当调用wait()方法的时候，线程会放弃对象锁，让出cpu该其他线程，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备


---------------------------------------------------------------------------------------------------------------------

## 多线程，到底该设置多少个线程？

[什么是QPS，TPS，吞吐量](https://www.jianshu.com/p/2fff42a9dfcf)


- 多线程效率不一定高于单线程，因为线程切换（时间、空间等）
- 多线程并发目的：提升CPU利用率，因为实际应用处理涉及网络IO、磁盘IO、计算型CPU，导致CPU空闲时间过长，因为等待文件操作，网络操作，数据库操作等
- 系统吞吐量（性能）几个重要参数：QPS（TPS）、并发数、响应时间

设置：  
- 最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目
- CPU密集型：操作内存处理的业务：CPU核数 + 1 或者 CPU核数*2
- IO密集型：文件操作，网络操作，数据库操作：CPU核数*N（N=10等，根据实际情况测试）


线程的执行，是由CPU进行调度的，一个CPU在同一时刻只会执行一个线程，我们看上去的线程A 和 线程B并发执行。

为了让用户感觉这些任务正在同时进行，操作系统利用了时间片轮转的方式，CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务。任务的状态保存及再加载，这段过程就叫做上下文切换。

上下文切换过程是需要时间的；现在我们来看一下上面的问题，小伙伴们再看一下是哪个方案快呢？是不是有些小伙伴们会说方案一，因为不需要线程切换；方案二需要来回切换这两个线程，耗时会多点。

常规的请求流程；我们看一下整个过程涉及到什么计算机处理。
- 1、网络请求----->网络IO
- 2、解析请求----->CPU
- 3、请求数据库----->网络IO
- 4、MySQL查询数据----->磁盘IO
- 5、MySQL返回数据----->网络IO
- 6、数据处理----->CPU
- 7、返回数据给用户----->网络IO

在真实业务中我们不单单会涉及CPU计算，还有网络IO和磁盘IO处理，这些处理是非常耗时的。如果一个线程整个流程是上图的流程，真正涉及到CPU的只有2个节点，其他的节点都是IO处理，那么线程在做IO处理的时候，CPU就空闲出来了，CPU的利用率就不高。

小伙伴们现在知道多线程的用处了吧，对，就是为了提升CPU利用率。


- TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。
- QPS：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。
- 吞吐量：一个系统的吞吐量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。



衡量系统性能如何，主要指标系统的（QPS/TPS）  
系统吞吐量（性能）几个重要参数：QPS（TPS）、并发数、响应时间  
- QPS（TPS）：每秒钟request/事务 数量，每秒能够处理请求/事务的数量
- 并发数： 系统同时处理的request/事务数，系统同时处理的请求/事务的数量
- 响应时间： 一般取平均响应时间，就是平均处理一个请求/事务需要时长



QPS（TPS）= 并发数/平均响应时间 或者 并发数 = QPS*平均响应时间

上面公式代表并发数越大，QPS就越大；所以很多人就会以为调大线程池，并发数就会大，也会提升QPS，所以才会出现一开始前言所说的，大多数人的误区。  
其实QPS还跟响应时间成反比，响应时间越大，QPS就会越小。  
虽然并发数调大了，就会提升QPS，但线程数也会影响响应时间，因为上面我们也提到了上下文切换的问题，那怎么设置线程数的呢？

最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目

备注这个公式也是前辈们分享的，当然之前看了淘宝前台系统优化实践的文章，和上面的公式很类似，不过在CPU数目那边，他们更细化了，上面的公式只是参考。不过不管什么公式，最终还是在生产环境中运行后，再优化调整。

我们继续上面的任务，我们的服务器CPU核数为4核，一个任务线程cpu耗时为20ms，线程等待（网络IO、磁盘IO）耗时80ms，那最佳线程数目：( 80 + 20 )/20 * 4 = 20。也就是设置20个线程数最佳。  
从这个公式上面我们就得出，线程的等待时间越大，线程数就要设置越大，这个正好符合我们上面的分析，可提升CPU利用率。那从另一个角度上面说，线程数设置多大，是根据我们自身的业务的，需要自己去压力测试，设置一个合理的数值。

- 1、CPU密集型：操作内存处理的业务，一般线程数设置为：CPU核数 + 1 或者 CPU核数*2。核数为4的话，一般设置 5 或 8
- 2、IO密集型：文件操作，网络操作，数据库操作，一般线程设置为：cpu核数 / (1-0.9)，核数为4的话，一般设置 40


---------------------------------------------------------------------------------------------------------------------
## 线程间的通信、同步方式与进程间通信方式

1、线程间的通信方式
使用全局变量
使用消息实现通信
使用事件CEvent类实现线程间通信


2、线程间的同步方式
线程间的同步方式有四种

临界区
互斥量
信号量
事件


3、进程间通信方式
- 1、低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)
- 2、高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等).



管道( pipe )
有名管道 (named pipe) 
信号量( semophore ) 
消息队列( message queue ) 
信号 ( signal ) 
[共享内存( shared memory )] 
套接字( socket ) 



[线程间的通信、同步方式与进程间通信方式](https://www.jianshu.com/p/9218692cb209)


---------------------------------------------------------------------------------------------------------------------

## 引起线程切换的几种方式

线程间的切换一般是操作系统层面需要考虑的问题，那么引起线程上下文切换有哪几种方式呢？或者说线程切换有哪几种诱因呢？主要有下面几种引起上下文切换的方式
1. 当前正在执行的任务完成，系统的 CPU 正常调度下一个需要运行的线程
2. 当前正在执行的任务遇到 I/O 等阻塞操作，线程调度器挂起此任务，继续调度下一个任务。
3. 多个任务并发抢占锁资源，当前任务没有获得锁资源，被线程调度器挂起，继续调度下一个任务。
4. 用户的代码挂起当前任务，比如线程执行 sleep 方法，让出CPU。
5. 使用硬件中断的方式引起上下文切换




---------------------------------------------------------------------------------------------------------------------

## 线程安全性定义、控制

要编写正确无误的线程安全的代码，其核心就是对状态访问操作进行管理。  
最重要的就是最 共享(Shared)的 和 可变(Mutable)的状态。  
只有共享和可变的变量才会出现问题，私有变量不会出现问题，参考程序计数器。


对象的状态可以理解为存储在实例变量或者静态变量中的数据，共享意味着某个变量可以被多个线程同时访问、可变意味着变量在生命周期内会发生变化。一个变量是否是线程安全的，取决于它是否被多个线程访问。

要使变量能够被安全访问，必须通过同步机制来对变量进行修饰。

如果不采用同步机制的话，那么就要避免多线程对共享变量的访问，主要有下面两种方式
1. 不要在多线程之间共享变量
2. 将共享变量置为不可变的




什么是线程安全性  
多个线程可以同时安全调用的代码称为线程安全的，如果一段代码是安全的，那么这段代码就不存在 竞态条件。仅仅当多个线程共享资源时，才会出现竞态条件。

根据上面的探讨，我们可以得出一个简单的结论：「当多个线程访问某个类时，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的」。

竞态条件  
它指的就是「两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)」 ，线程切换是导致竞态条件出现的诱导因素


竞态条件和关键区域 

竞态条件是在关键代码区域发生的一种特殊条件。关键区域是由多个线程同时执行的代码部分，关键区域中的代码执行顺序会对造成不一样的结果。如果多个线程执行一段关键代码，而这段关键代码会因为执行顺序不同而造成不同的结果时，那么这段代码就会包含竞争条件。





线程安全的控制：
- 加锁机制：synchronized（悲观锁）、volatile、Atomic开头的原子类（乐观锁）


加锁机制

Java 提供一种内置的机制对资源进行保护：synchronized 关键字，它有三种保护机制
- 对方法进行加锁，确保多个线程中只有一个线程执行方法；
- 对某个对象实例（在我们上面的探讨中，变量可以使用对象来替换）进行加锁，确保多个线程中只有一个线程对对象实例进行访问；
- 对类对象进行加锁，确保多个线程只有一个线程能够访问类中的资源。

synchronized 关键字对资源进行保护的代码块俗称 同步代码块(Synchronized Block)

每个 Java 对象都可以用做一个实现同步的锁，这些锁被称为 内置锁(Instrinsic Lock)或者 监视器锁(Monitor Lock)。  
线程在进入同步代码之前会自动获得锁，并且在退出同步代码时自动释放锁，而无论是通过正常执行路径退出还是通过异常路径退出，获得内置锁的唯一途径就是进入这个由锁保护的同步代码块或方法。

synchronized 的另一种隐含的语义就是 互斥，互斥意味着独占【同一个时刻的独占】



volatile 是一种轻量级的 synchronized，也就是一种轻量级的加锁方式，volatile 通过保证共享变量的可见性来从侧面对对象进行加锁。  
可见性的意思就是当一个线程修改一个共享变量时，另外一个线程能够 看见 这个修改的值。  
volatile 的执行成本要比 synchronized 低很多，因为 volatile 不会引起线程的上下文切换。


原子类 来保证线程安全，原子类其实就是 rt.jar 下面以 atomic 开头的类





共享状态还是独立状态

共享状态也就意味着在不同线程之间共享某些状态

状态其实就是数据，比如一个或者多个对象。当线程要共享数据时，就会造成 竞态条件 或者 死锁 等问题。

独立的状态表明状态不会在多个线程之间共享，如果线程之间需要通信的话，他们可以访问不可变的对象来实现，这是最有效的避免并发问题的一种方式，

使用独立状态让我们的设计更加简单，因为只有一个线程能够访问对象，即使交换对象，也是不可变的对象。





并发模型 
1. 并行 Worker：
2. 流水线并发模型【响应式 - 事件驱动系统】
3. 函数性并行
4. 
5. 


并行 worker 的核心思想是，它主要有两个进程即代理人和工人，Delegator 负责接收来自客户端的任务并把任务下发，交给具体的 Worker 进行处理，Worker 处理完成后把结果返回给 Delegator，在 Delegator 接收到 Worker 处理的结果后对其进行汇总，然后交给客户端。



流水线并发模型

这种组织架构就像是工厂中装配线中的 worker，每个 worker 只完成全部工作的一部分，完成一部分后，worker 会将工作转发给下一个 worker。

每道程序都在自己的线程中运行，彼此之间不会共享状态，这种模型也被称为无共享并发模型。

使用流水线并发模型通常被设计为非阻塞I/O，也就是说，当没有给 worker 分配任务时，worker 会做其他工作。

使用流水线模型的系统有时也被称为 响应式 或者 事件驱动系统，这种模型会根据外部的事件作出响应，事件可能是某个 HTTP 请求或者某个文件完成加载到内存中。


函数性并行模型是最近才提出的一种并发模型，它的基本思路是使用函数调用来实现。  
消息的传递就相当于是函数的调用。传递给函数的参数都会被拷贝，因此在函数之外的任何实体都无法操纵函数内的数据。这使得函数执行类似于原子操作。每个函数调用都可以独立于任何其他函数调用执行。



---------------------------------------------------------------------------------------------------------------------

## Java线程的创建和分类

在 Java 中，创建线程的方式主要有三种
1. 通过继承 Thread 类来创建线程
2. 通过实现 Runnable 接口来创建线程
3. 通过 Callable 和 Future 来创建线程



线程优先级

可以通过设置线程的优先级状态，告诉线程调度器哪个线程的执行优先级比较高  
线程调度器倾向于让优先级较高的线程优先执行，然而，这并不意味着优先级低的线程得不到执行，  
也就是说，优先级不会导致死锁的问题。优先级较低的线程只是执行频率较低。

尽管 JDK 有 10 个优先级，但是一般只有「MAX_PRIORITY，NORM_PRIORITY，MIN_PRIORITY」 三种级别。




后台(daemon)线程

后台(daemon)线程，是指运行时在后台提供的一种服务线程，这种线程不是属于必须的。当所有非后台线程结束时，程序也就停止了，**同时会终止所有的后台线程。**反过来说，只要有任何非后台线程还在运行，程序就不会终止。




线程方法：  
- Thread.sleep()：sleep方法只让出了CPU，而并不会释放同步资源锁
- thread.wait()：wait()方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。
- Thread.yield() 是建议执行切换CPU，而不是强制执行CPU切换。
- join() 方法：其效果是等待一段时间直到第二个线程结束才正常执行。join() 方法等待线程死亡。换句话说，它会导致当前运行的线程停止执行，直到它加入的线程完成其任务。




线程异常捕获

由于线程的本质，使你不能捕获从线程中逃逸的异常，一旦异常逃出任务的 run 方法，它就会向外传播到控制台，除非你采取特殊的步骤捕获这种错误的异常，  
在 Java5 之前，你可以通过线程组来捕获，但是在 Java 5 之后，就需要用 Executor 来解决问题，因为线程组不是一次好的尝试。


为了解决这个问题，我们需要修改 Executor 产生线程的方式，Java5 提供了一个新的接口 Thread.UncaughtExceptionHandler ，它允许你在每个 Thread 上都附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException() 会在线程因未捕获临近死亡时被调用。

在程序中添加了额外的追踪机制，用来验证工厂创建的线程会传递给UncaughtExceptionHandler，你可以看到，未捕获的异常是通过 uncaughtException 来捕获的。






在Java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口.(其实准确来讲，应该有三种，还有一种是实现Callable接口，并与Future、线程池结合使用，

注意：start()方法的调用后并不是立即执行多线程代码，而是使得该线程变为可运行态（Runnable），什么时候运行是由操作系统决定的。  
从程序运行的结果可以发现，多线程程序是乱序执行。因此，只有乱序执行的代码才有必要设计为多线程。  
Thread.sleep()方法调用目的是不让当前线程独自霸占该进程所获取的CPU资源，以留出一定时间给其他线程执行的机会。  
实际上所有的多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。  
但是start方法重复调用的话，会出现java.lang.IllegalThreadStateException异常。


Thread2类通过实现Runnable接口，使得该类有了多线程类的特征。run（）方法是多线程程序的一个约定。所有的多线程代码都在run方法里面。Thread类实际上也是实现了Runnable接口的类。  
在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target) 构造出对象，然后调用Thread对象的start()方法来运行多线程代码。  
实际上所有的多线程代码都是通过运行Thread的start()方法来运行的。因此，不管是扩展Thread类还是实现Runnable接口来实现多线程，最终还是通过Thread的对象的API来控制线程的，熟悉Thread类的API是进行多线程编程的基础。  


Thread和Runnable的区别  
如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。  
总结：  
实现Runnable接口比继承Thread类所具有的优势：
- 1）：适合多个相同的程序代码的线程去处理同一个资源
- 2）：可以避免java中的单继承的限制
- 3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立
- 4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类
 

提醒一下大家：main方法其实也是一个线程。在java中所以的线程都是同时启动的，至于什么时候，哪个先执行，完全看谁先得到CPU的资源。  
在java中，每次程序运行至少启动2个线程。一个是main线程，一个是垃圾收集线程。因为每当使用java命令执行一个类的时候，实际上都会启动一个ＪＶＭ，每一个JVM实习在就是在操作系统中启动了一个进程。




参考  
[Java中sleep()与wait()区别](https://blog.csdn.net/u012050154/article/details/50903326)  
[2w字 + 40张图带你参透并发编程！](https://mp.weixin.qq.com/s/-PRq4ChaCkEFB_DJyyKhvg )  
[代码参考](../../src/test/java/org/quickstart/javase/jdk/thread/ExceptionThread2.java)  


---------------------------------------------------------------------------------------------------------------------


Future接口 按照提交顺序获取结果 CPU高速轮询，耗资源，或者阻塞，可以使用，但不推荐
CompletionService  内部通过阻塞队列+FutureTask接口 支持任务完成的先后顺序
CompletableFuture JDK8实现了Future, CompletionStage两个接口 API极端丰富，配合流式编程，推荐使用！




[012-Future、FutureTask、CompletionService 、CompletableFuture](https://blog.csdn.net/weixin_34384915/article/details/86133434)
[多线程并发执行任务，取结果归集。终极总结：Future、FutureTask、CompletionService、CompletableFuture](https://www.cnblogs.com/dennyzhangdd/p/7010972.html)
