- [Java基础](#Java基础)
    - [JavaOOM类型](JavaSE/JavaOOM类型/JavaOOM类型.md)
    - [正则表达式Regex](JavaSE/正则表达式Regex/正则表达式Regex.md)
    - [bit、byte、位、字节、汉字的关系](JavaSE/bit、byte、位、字节、汉字的关系.md)
    - [BloomFilter与CuckooFilter](JavaSE/BloomFilter与CuckooFilter.md)
    - [ClassLoader学习](JavaSE/ClassLoader学习.md)
    - [copyonwrite机制](JavaSE/copyonwrite机制.md)
    - [CPU缓存和内存屏障](JavaSE/CPU缓存和内存屏障.md)
    - [java new一个对象的过程中发生了什么](JavaSE/java new一个对象的过程中发生了什么.md)
    - [javaagent](JavaSE/javaagent.md)
    - [Java中boolean类型占用多少个字节](JavaSE/Java中boolean类型占用多少个字节.md)
    - [Java中char](JavaSE/Java中char.md)
    - [java中有三种移位运算符](JavaSE/java中有三种移位运算符.md)
    - [Java反射和agent](JavaSE/Java反射和agent.md)
    - [Java接口默认实现方法](JDK8/Java接口默认实现方法.md)
    - [Java System.getProperty vs System.getenv](JavaSE/Java System.getProperty vs System.getenv.md)
    - [java的jar和war的打包解压](JavaSE/java的jar和war的打包解压.md)
    - [Java的简单类型及其封装器类](JavaSE/Java的简单类型及其封装器类.md)
    - [java读取文件方式](JavaSE/java读取文件方式.md)
    - [JAVA调用系统命令Process](JavaSE/JAVA调用系统命令Process.md)
    - [Java链式调用-Builder模式](JavaSE/Java链式调用-Builder模式.md)
    - [Java锁学习](JavaSE/Java锁学习.md)
    - [JMX](JavaSE/JMX.md)
    - [JVM与Linux的内存关系详解](JVM/JVM与Linux的内存关系详解.md)
    - [N进制转换](JavaSE/N进制转换.md)
    - [OracleJDK和OpenJDK](JavaSE/OracleJDK和OpenJDK.md)
    - [SecureRandom详解](JavaSE/SecureRandom详解.md)
    - [servlet介绍](JavaSE/servlet介绍.md)
    - [Thread线程学习](concurrent/Thread线程学习.md)
    - [unsafe类学习](concurrent/unsafe类学习.md)
    - [从n个数选出最大的m个的算法比较](JavaSE/从n个数选出最大的m个的算法比较.md)
    - [代码优化](JavaSE/代码优化.md)
    - [内存泄漏](JavaSE/内存泄漏.md)
    - [内部类](JavaSE/内部类.md)
    - [单例模式](JavaSE/单例模式.md)
    - [图片加载缓慢优化](JavaSE/图片加载缓慢优化.md)
    - [如何优雅地根治null值](JavaSE/如何优雅地根治null值.md)
    - [如何计算Java对象所占内存的大小](JavaSE/如何计算Java对象所占内存的大小.md)
    - [定位常见Java性能问题](JavaSE/定位常见Java性能问题.md)
    - [怎么设计hashcode更均衡](collection/怎么设计hashcode更均衡.md)
    - [日期处理类库](JavaSE/日期处理类库.md)
    - [泛型通配符extends与super的区别](JavaSE/泛型通配符extends与super的区别.md)
    - [深入理解JAVA反序列化漏洞](JavaSE/深入理解JAVA反序列化漏洞.md)
    - [深入理解JAVA反序列化漏洞PDF](JavaSE/深入理解JAVA反序列化漏洞.pdf)
    - [负载均衡](JavaSE/负载均衡.md)
    - [进程，线程和协程的区别](JavaSE/进程，线程和协程的区别.md)
    - [重写hashCode()方法和equals()方法及如何重写](JavaSE/重写hashCode()方法和equals()方法及如何重写.md)
    - [锁的种类](JavaSE/锁的种类.md)
    - [零拷贝](JavaSE/零拷贝.md)
    - [JavaOOM类型](#JavaOOM类型)
    - [Java泛型的类型擦除和Java语法糖](#Java泛型的类型擦除和Java语法糖)
    - [sleep和wait方法](#sleep和wait方法)
    - [jar包和替换jar包类](#jar包和替换jar包类)
    - [java中的数字魔法](#java中的数字魔法)
    - [Java到底是值传递还是引用传递](#Java到底是值传递还是引用传递)
    - [java8lambda表达式的优缺点总结](#java8lambda表达式的优缺点总结)
    - [java在读多写少、写多读少分别使用什么类](#java在读多写少、写多读少分别使用什么类)
    - [Java如何避免NULL](#Java如何避免NULL)
    - [为什么 Java 的 main 方法必须是 public static void](#为什么-Java-的-main-方法必须是-public-static-void)
    - [时间格式中的T和Z表示什么](#时间格式中的T和Z表示什么)
    - [Java线程的6种状态及切换](#Java线程的6种状态及切换)
    - [虚拟机线程状态 vs 操作系统线程状态](#虚拟机线程状态-vs-操作系统线程状态)
    - [Java线程和操作系统线程的关系](#Java线程和操作系统线程的关系)
    - [sleep和yield和wait和join的区别](#Sleep和yield和wait和join的区别)
    - [Java线程和操作系统线程的关系](#Java线程和操作系统线程的关系)
    - [Java中判断字符串是否是数字的几种方法](#Java中判断字符串是否是数字的几种方法)
- [Java集合](#Java集合)
    - [HashMap和ConcurrentHashMap学习](collection/HashMap和ConcurrentHashMap学习.md)
    - [java集合](collection/Java集合.md)
- [Java并发](#Java并发)
    - [Java并发编程的艺术](concurrent/Java并发编程的艺术.pdf)
    - [Java多线程学习](concurrent/Java多线程学习.md)
    - [java并发包concurrent和并发工具类](concurrent/java并发包concurrent和并发工具类.md)
    - [java并发基础AQS类](concurrent/java并发基础AQS类.md)
    - [ThreadPool线程池](concurrent/ThreadPool线程池.md)
    - [并发编程学习](concurrent/并发编程学习.md)
- [JVM](#JVM)
    - [ClassLoader种类和类隔离](JVM/ClassLoader种类和类隔离.md)
    - [HotSpot VM](JVM/HotSpot VM.md)
    - [java-GC日志分析](JVM/java-GC日志分析.md)
    - [JVM参数](JVM/JVM参数.md)
    - [jvm学习](JVM/jvm学习.md)
    - [openjdk](JVM/OpenJDK.md)
    - [获取JVM进程的线程堆栈dump和堆dump](JVM/获取JVM进程的线程堆栈dump和堆dump.md)
- [I/O](#IO)
    - [epoll的ET和LT模式详解](IO/epoll的ET和LT模式详解.md)
    - [IO整体](IO/IO整体.md)
    - [java-AIO](IO/java-AIO.md)
    - [java-BIO](IO/java-BIO.md)
    - [java-nio](IO/java-nio.md)
    - [Java直接内存](IO/Java直接内存.md)
- [JDK8](#JDK8)
    - [CompletableFuture学习](JDK8/CompletableFuture学习.md)
    - [ForkJoin框架](JDK8/ForkJoin框架.md)
    - [JDK8学习](JDK8/JDK8学习.md)
    - [Lambda表达式和函数式接口](JDK8/Lambda表达式和函数式接口.md)
    - [ManagedBlocker学习](JDK8/ManagedBlocker学习.md)
    - [StreamAPI学习](JDK8/StreamAPI学习.md)
    - [函数式编程FP和反应式编程RP](JDK8/函数式编程FP和反应式编程RP.md)
    - [函数式编程（functional programming）](JDK8/函数式编程（functional programming）.md)
- [JDK9](#JDK9)
    - [JDK9以上学习](JDK9/JDK9以上学习.md)



学习网站
https://www.toutiao.com/c/user/93762594808/#mid=1594621692172296



---------------------------------------------------------------------------------------------------------------------

--------------------------------
[西瓜]GC基础知识
[西瓜]GC算法
[西瓜]JVM的垃圾回收器
[西瓜]实战调优
[西瓜]简历上如何敢写“有过JVM调优经验”


[握手]手把手学NIO/EPOLL,从java代码到系统调用
--------------------------------------

1，为什么IO这么重要

2，阻塞和非阻塞的本质区别

3，java是如何实现非阻塞的

4，java代码和内核如何交互

5，epoll算异步io吗？

6，NIO和多路复用器的差异

7，技术学习到什么程度就够了

8，IO在面试中起到的作用
---------------------------------------
[勾引]戳此进直播间啦：https://ke.qq.com/webcourse/index.html?cid=399017&term_id=100475965&taid=9751182080087721&from=41




[坏笑]完整成体系的从BIO到NIO到EPOLL多路复用器
----------------
🔔网络IO的本质是什么
🔔BIO模型如何实现通信，优缺点？
🔔NIO在内核中的表现是什么，优缺点？
🔔NIO在JDK中的表现是什么，优缺点？
🔔多路复用器的演变过程是什么？
🔔select，poll，epoll多路复用器的差异？
🔔IO知识体系的重要性，重点在那里？
🔔什么是系统调用？
🔔什么是内核？和IO什么关系？
🔔不同IO模型在内核的演变过程？
----------------
🚀戳此进直播间：https://ke.qq.com/course/399017?taid=10573088496686761&tuin=a028e035




[奋斗]马士兵：你真的了解synchronized?
-----------------------------------
[爱心]什么是CAS，CAS在底层如何实现

[爱心]什么是JOL，JOL的基本使用

[爱心]对象的内存布局

[爱心]synchronized对于对象头的影响

[爱心]synchronized升级概述

[爱心]偏向锁 - 轻量级锁详解

[爱心]深入汇编层面理解sychronized
---------------------------
[勾引]戳此进直播间啦：https://ke.qq.com/course/399017?taid=9800909211440809&tuin=6c381156
[怄火]月末最后一晚的优惠福利活动啦，大家抓紧机会找你们的咨询小姐姐，过了12点涨价啦，是时候做出改变了！！！


----------------
马士兵亲授：NB美团7连问,JVM到骨髓
[吃瓜]请解释对象的创建过程？
[吃瓜]DCL需不需要volatile？
[吃瓜]请解释对象在内存中的存储布局
[吃瓜]对象头具体包括什么？
[吃瓜]JVM如何定位一个对象？
[吃瓜]对象在内存中如何分配？栈上？堆上
[吃瓜]一个Object对象在内存中占用多少字节？
----------------


🎉主讲老师：马士兵老师
👉为什么一个百万级TPS系统会频繁GC？
用top命令观察系统运行情况
👉用jps定位虚拟机进程
👉用jstat定位JVM问题
👉用jmap导出内存转储文件
👉用jstack定位问题线程



[色]线程私家领地ThreadLocal居然会有内存泄漏？
----------------
🎈不常用不代表不重要，详解强软弱虚四种引用
🎈ThreadLocal到底存不存在内存泄漏？
🎈深入JDK源码解读ThreadLocal的私有领地
🎈面试官问题ThreadLocal泄漏问题如何回答才完善？





[疑问]java程序员需要开辟第二语言吗？
----------------
🎈go语言和java的异同点
🎈指针和引用
🎈传值和传指针
🎈go语言里面的协程


全网最细致讲解Lambda表达式和函数式接口
--------------------------------
.Lambda表达式先睹为快
.Lambda表达式语法
.函数式接口
.方法引用
.构造器引用
.数组引用
跨行、0基础、低学历，3个月如何让你从0到高薪就业
解析IT行业就业前景
直播间等你们呦：https://ke.qq.com/webcourse/index.html?cid=399017&term_id=100475965&taid=9751182080087721&from=41





---------------------------------------------------------------------------------------------------------------------


java中的数字魔法：
1、缓存问题：对于int的变量，在对于值范围在-128到127之间的数，==是相等的，超过这个范围的因为自动装箱，是两个不同的Integer对象，==就不相等了
2、越界问题：
  i==Math.abs(i)： Long、Short、Byte等的如负数Integer.MIN_VALUE值等于自己绝对值Math.abs(Integer.MIN_VALUE))
  i+1<i ：Integer.MAX_VALUE，因为+1越界成为负数
  i != 0 && i == -i：还是Integer.MIN_VALUE
3、浮点奥秘：
  i=i+1，i=i-1：Double.POSITIVE_INFINITY代表正无穷大，正无穷大加减一个数还是正无穷大
  i != i：Double.NaN，



一、缓存问题
JAVA编译器编译Integer a = 50的时候,被翻译成Integer a = Integer.valueOf(50);
而valueOf的源码是下面这样的
‍看到了嘛，Integer内部有一个IntegerCache缓存。对于值范围在-128到127之间的数，会进行缓存。因此a和b范围在-128到127之间，所以指向的是同一个对象，所以判断结果是true。而c和d在128之外，所以每次都是返回一个新对象，所以判断结果是false。


二、越界问题
Math.abs(Integer.MIN_VALUE))的结果是正数还是负数
绝对值运算的原理是判断这个数是否大于零，如果小于零则取负值
Integer.MIN_VALUE，它的十六进制表示是 0x80000000。其符号位为1，其余所有的位都是0。取负数(反码+1)则为 0x7fffffff+1，也就是 0x80000000。你会发现对Integer.MIN_VALUE取负值还是本身。因此，结果还是负数。
这套理论对Long、Short、Byte都成立
Math.abs(Short.MIN_VALUE)=它本身-32768
是否存在一个数i，可以使其满足i+1<i，这样看来，这个i就是Integer.MAX_VALUE，因为加完1就溢出了变为负值了。"
是否存在一个数，满足i != 0 && i == -i"其实还是Integer.MIN_VALUE，原因你刚才说过了！"


三、浮点奥秘
double i = Double.POSITIVE_INFINITY代表正无穷大，无穷大加一个常数还是无穷大，无穷大减去一个常数也是无穷大
所以 i 等于 i+1 等于 i-1

double j = Double.NaN;翻译过来就是(Not a Number)，所以他本身不等于它本身 j != j 是true



---------------------------------------------------------------------------------------------------------------------

java7开始提供Aio的实现，BIO、NIO、AIO
https://blog.csdn.net/anxpp/article/details/51512200
https://www.cnblogs.com/diegodu/p/6823855.html
https://www.cnblogs.com/doit8791/p/4951591.html



Java transient关键字使用小记
https://www.cnblogs.com/lanxuezaipiao/p/3369962.html




ClassLoader 详解及用途
https://blog.csdn.net/u010015108/article/details/52025220

Java代码编译过程简述
https://blog.csdn.net/fuzhongmin05/article/details/54880257


AccessController.doPrivileged
http://blog.csdn.net/laiwenqiang/article/details/54321588


Spring Boot 1.5.8.RELEASE同时配置Oracle和MySQL
https://segmentfault.com/a/1190000012148813
http://blog.csdn.net/thl331860203/article/details/77849662


redis两种持久化方式的优缺点
https://www.cnblogs.com/ssssdy/p/7132856.html


kafka配置
https://hacpai.com/article/1501331595492

https://github.com/search?o=desc&q=tutorials&s=stars&type=Repositories
https://github.com/search?utf8=%E2%9C%93&q=tutorials&type=Repositories


Jupyter notebook（又称IPython notebook）是一个交互式的笔记本，支持运行超过40种编程语言。
https://jupyter.org/
https://jupyterhub.readthedocs.io/en/latest/



JVM安全退出（如何优雅的关闭java服务）：Runtime.addShutdownHook(Thread hook)注册自定义钩子
http://www.voidcn.com/article/p-wfdtbucc-bbs.html


使用ThreadGroup监控线程退出
http://yang.run/2016/03/29/Using-ThreadGroup-to-monitor-thread-exit/


---------------------------------------------------------------------------------------------------------------------

## java在读多写少、写多读少分别使用什么类

java并发控制参考
docs/java并发包concurrent和并发工具类.md中的并发工具类


并发控制：
1、乐观锁
2、读写锁：分治思想



在读多写少的环境下使用
1、ConcurrentHashMap
2、copyonwrite的机制：CopyOnWriteArrayList，CopyOnWriteArraySet。
3、读写锁实现



在写多读少环境下：
1、ConcurrentHashMap的思想：切分
2、CAS变量


---------------------------------------------------------------------------------------------------------------------

Java到底是值传递还是引用传递




参考  
https://www.zhihu.com/question/31203609  



---------------------------------------------------------------------------------------------------------------------
## Java如何避免NULL



相对于判空语句，更好的检查方式有两个  
(1)assert语句，你可以把错误原因放到assert的参数中，这样不仅能保护你的程序不往下走，而且还能把错误原因返回给调用方，岂不是一举两得。（原文介绍了assert的使用，这里省略）  
(2)也可以直接抛出空指针异常。上面说了，此时null是个不合理的参数，有问题就是有问题，就应该大大方方往外抛。  



1、假如方法的返回类型是collections，当返回结果是空时，你可以返回一个空的collections（empty list),而不要返回null  
2、返回类型不是collections，那就返回一个空对象（而非null对象）  




1、如果要用equal方法，请用object<不可能为空>.equal(object<可能为空>))  
2、Java8或者guava lib中，提供了Optional类，这是一个元素容器，通过它来封装对象，可以减少判空。不过代码量还是不少。不爽。  
3、如果你想返回null，请挺下来想一想，这个地方是否更应该抛出一个异常  



参考  
https://blog.csdn.net/lizeyang/article/details/40040817  


---------------------------------------------------------------------------------------------------------------------
## 为什么 Java 的 main 方法必须是 public static void


1.main 方法必须声明为 public、static、void，否则 JVM 没法运行程序 。



参考  
https://cloud.tencent.com/developer/article/1704387  



---------------------------------------------------------------------------------------------------------------------
## 时间格式中的T和Z表示什么


GMT时区是格林威治标准时间，我把它理解为 “真实时间”

UTC时区是根据GMT得来的“世界标准时间”，它的时间和GMT是相同的

CST可以指下列的时区：

澳洲中部时间，Central Standard Time (Australia)中部标准时区（北美洲），Central Standard Time (North America)北京时间，China Standard Time古巴标准时间，Cuba Standard Time，参见北美东部时区

其中我们所在的时区背景时间 CST=UTC+8小时，也就是说，真实时间是0点的时候，背景时间是8点





参考  
https://zoucz.com/blog/2016/01/29/date-iso/  
https://blog.csdn.net/aerchi/article/details/78717232  

---------------------------------------------------------------------------------------------------------------------

## Java线程的6种状态及切换

## 虚拟机线程状态 vs 操作系统线程状态

Java语言定义了6种线程状态，在任意一个时间点钟，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间切换。

- 新建（New）：创建后尚未启动的线程处于这种状态。

- 运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处理此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。

- 无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显示唤醒。
    1、没有设置Timeout参数的Object::wait()方法；
    2、没有设置Timeout参数的Thread::join()方法；
    3、LockSupport::park()方法。
    
- 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。
    1、Thread::sleep()方法；
    2、设置了Timeout参数的Object::wait()方法；
    3、设置了Timeout参数的Thread::join()方法；
    4、LockSupport::parkNanos()方法；
    5、LockSupport::parkUntil()方法；
    
- 阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间 ，或者唤醒动作发生。在程序进入同步区域的时候，线程将进入这种状态。

- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。



操作系统中线程状态：
从实际意义上来讲，操作系统中的一个线程真实存在的状态，只有：
- ready：表示线程已经被创建，正在等待系统调度分配CPU使用权。
- running：表示线程获得了CPU使用权，正在进行运算
- waiting：表示线程等待（或者说挂起），让出CPU资源给其他线程使用


无论是Timed Waiting ，Waiting还是Blocked，对应的都是操作系统线程的**waiting（等待**）状态。  
而Runnable状态，则对应了操作系统中的ready和running状态。



参考  
https://blog.csdn.net/pange1991/article/details/53860651  
https://www.cnblogs.com/jimoer/p/13283355.html  
https://www.cnblogs.com/aspirant/p/8900276.html  
https://www.jianshu.com/p/7c980955627e  
https://blog.winsky.wang/Java/Java%E5%9F%BA%E7%A1%80/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/  
https://blog.csdn.net/CringKong/article/details/79994511



---------------------------------------------------------------------------------------------------------------------

## Java线程和操作系统线程的关系

### 线程的实现

主流的操作系统都提供了线程实现，Jav语言则是提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经调用过start()方法且还未结束的java.lang.Thread类的实例就代表这一个线程。

其实Thread类与大部分的Java类库API有着显著差别，它的所有关键方法都被声明为Native。在Java中，一个Native方法往往就意味着这个方法没有使用或无法使用平台无关的手段来实现（通常最高效率的手段就是平台相关的手段）。

那么线程的实现其实是有三种方式的：
- 使用内核线程实现（1:1实现）；
- 使用用户线程实现（1:N）实现；
- 使用用户线程加轻量级进程（LWP）混合实现；


### 内核线程实现
使用内核线程实现的方式被称为1:1实现。内核线程（Kernel Levvel Thread，KLT）就是直接由操作系统内核（Kernel，下称内核）支持的线程，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。

其实程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程（Light Weight Process,LWP），轻量级进程就是我们通常所讲的线程。这种轻量级进程与内存线程之间1:1的关系称为一对一的线程模型。

轻量级进程也具有它的局限性：首先，由于是基于内核线程实现的，所以各种线程操作（创建、析构及同步），都需要进行系统调用。系统调用就要在用户态和内核态中来回切换。其次，每个轻量级进程都需要一个内核线程的支持，因此需要消耗一定的内核资源，所以一个系统支持轻量级进程的数量是有限的。



### 用户线程实现
使用用户线程实现的方式被称为1:N实现。广义上来讲，一个线程只要不是内核线程，都可以任务是用户线程（User Threa，UT）的一种。从定义上来看轻量级进程不是内核线程也就是属于用户线程，但是它始终是建立在内核之上的，所以效率会受到限制，并不具备用户线程的优点。

用户线程的建立、同步、销毁和调度完全咋用户态中完成，不需要内核帮助。如果程序实现得当，不需要切换内核态，因此操作可以是非常快且低消耗的，也能够支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。

这种进程与用户线程之间1:N的关系称为一对多的线程模型。


用户线程的速度快低消耗等优势在于不需要系统内核支援，但是劣势也在于没有内核的支援，所有的线程操作都需要由用户程序自己去处理。这样就会导致线程的一些问题处理起来就很困难，甚至有些是不可能实现的。
Java、Ruby等予以都曾经使用过用户线程，最终又都放弃了使用它。




### 混合实现
线程除了依赖内核线程实现和完全由用户程序自己实现之外，还有一种将内核线程与用户线程一起使用的实现方式，被称为N:M实现。

用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险。



### Java线程调度
线程调度是指系统为线程分配处理使用权的过程，调度主要方式有两种，分别是协同式（Cooperative Threads-Scheduling）线程调度和抢占式（Preemptive Threads-Scheduling）线程调度。

协同式线程调度：线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上去。  
优点：实现简单，切换操作对线程自己是可知的，所以一般没有什么线程同步问题。  
缺点：线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。  

抢占式线程调度：每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。  
优点：可以主动让出执行时间（例如Java的Thread::yield()方法），并且线程的执行时间是系统可控的，也不会有一个线程导致整个系统阻塞的问题。  
缺点：无法主动获取执行时间。  

Java使用的就是抢占式线程调度，虽然这种方式的线程调度是系统自己的完成的，但是我们可以给操作系统一些建议，就是通过设置线程优先级来实现。  
Java语言一共设置了10个级别的线程优先级。在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。

不过由于各个系统的提供的优先级数量不一致，所以导致Java提供的10个级别的线程优先级并不见得能与各系统的优先级都一一对应。




### Java线程状态转换

Java语言定义了6种线程状态，在任意一个时间点钟，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间切换。

- 新建（New）：创建后尚未启动的线程处于这种状态。

- 运行（Runnable）：包括操作系统线程状态中的Running和Ready，也就是处理此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。

- 无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显示唤醒。
    1、没有设置Timeout参数的Object::wait()方法；
    2、没有设置Timeout参数的Thread::join()方法；
    3、LockSupport::park()方法。
    
- 限期等待（Timed Waiting）：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。
    1、Thread::sleep()方法；
    2、设置了Timeout参数的Object::wait()方法；
    3、设置了Timeout参数的Thread::join()方法；
    4、LockSupport::parkNanos()方法；
    5、LockSupport::parkUntil()方法；
    
- 阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间 ，或者唤醒动作发生。在程序进入同步区域的时候，线程将进入这种状态。

- 结束（Terminated）：已终止线程的线程状态，线程已经结束执行。



参考  
https://www.cnblogs.com/jimoer/p/13283355.html  


---------------------------------------------------------------------------------------------------------------------

## Sleep和yield和wait和join的区别
sleep、yield、wait、join的区别

只有runnable到running时才会占用cpu时间片，其他都会出让cpu时间片。

线程的资源有不少，但应该包含CPU资源和锁资源这两类。  
sleep(long mills)：让出CPU资源，但是不会释放锁资源。  
wait()：让出CPU资源和锁资源。  
sleep与Wait的区别：sleep是线程方法，wait是object方法；看区别，主要是看CPU的运行机制：


1. Thread.sleep(long) 和Thread.yield()都是Thread类的静态方法，在调用的时候都是Thread.sleep(long)/  Thread.yield()的方式进行调用。  

   而join()是由线程对象来调用。

2. wait()和notify()、notifyAll()  这三个方法都是java.lang.Object的方法!  

    它们都是用于协调多个线程对共享数据的存取，所以必须在Synchronized语句块内使用这三个方法。  

    (1) wait()方法使当前线程暂停执行并释放对象锁标志，让其他线程可以进入Synchronized数据块，当前线程被放入对象等待池中。

    (2) 当调用 notify()方法后，将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中的线程能够获取锁标志；如果锁标志等待池中没有线程，则notify()不起作用。 
    
    (3) notifyAll()则从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中。 



最后： 

1.sleep：Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段），提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁  可通过调用interrupt()方法来唤醒休眠线程。

2.yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。

3.wait：Object类的方法(notify()、notifyAll()  也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁

4.join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。

等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。




参考  
https://www.cnblogs.com/aspirant/p/8876670.html  



---------------------------------------------------------------------------------------------------------------------

## Java中判断字符串是否是数字的几种方法


[Java中判断字符串是否是数字的几种方法](https://blog.csdn.net/u013777975/article/details/80845703)



---------------------------------------------------------------------------------------------------------------------







---------------------------------------------------------------------------------------------------------------------







