- [Java IO分类](#Java-IO分类)
- [I/O多路复用技术](#I/O多路复用技术)
- [I/O模型：同步I/O和异步I/O，阻塞I/O和非阻塞I/O](#I/O模型：同步I/O和异步I/O，阻塞I/O和非阻塞I/O)
- [EPOLL事件有两种模型](#EPOLL事件有两种模型)
- [用户空间与内核空间](#用户空间与内核空间)


-------------------------------------------------------------------------

Scalable IO in Java：http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf  
李林峰的netty系列文章：http://www.infoq.com/cn/minibooks/netty-in-depth  
BIO NIO AIO到底是什么鬼？看这篇文章就够了。http://www.cnblogs.com/dolphin0520/p/3916526.html  
https://github.com/zy475459736/On-the-Way/blob/master/NettySeries/网络传输模型.md  
  
http://ifeve.com/overview/  
  
另外这个是蚂蚁开源的基于netty的实践通信框架，代码不多，很适合学习网络编程。也可以看下https://github.com/alipay/sofa-bolt  
用AIO写的框架，可以看下：https://git.oschina.net/smartboot/smart-socket  
  
从底层入手，图解 Java NIO BIO MIO AIO 四大IO模型与原理  
https://blog.csdn.net/crazymakercircle/article/details/85858596  
https://my.oschina.net/haitaohu/blog/1844621  
https://blog.csdn.net/github_38737621/article/details/80216082  




## Java IO分类
文件IO、网络IO  
BIO、NIO、AIO  
  
网络IO分为：BIO、NIO、AIO  
BIO和NIO中都有文件IO  
  
  
Java NIO：  
BIO是面向流、阻塞IO，顺序读  
NIO面向缓冲、非阻塞IO、选择器Selector，可以使用position等跳跃读  
  
标准的IO基于字节流和字符流进行操作的  
NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。      
  
  
文件IO、网络IO、  
  
Linux文件IO和文件标准IO  
http://blog.csdn.net/yzhang6_10/article/details/53142733  
https://www.cnblogs.com/xiaojiang1025/p/5933755.html  
对UNIX系统来说，可用的文件I/O函数主要有：打开文件、读文件、写文件等。涉及到的函数主要有：open、read、write、lseek、close，其中不带缓冲指每个read和write都调用内核中的一个系统调用。涉及多个进程间共享资源时，原子操作就非常重要。  
  
文件描述符（fd，File descriptor）：对内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。  
在符合POSIX.1的应用程序中，幻数0、1、2虽然已被标准化，但应当把它们替换成富豪常量STDIN_FILENO、STDOUT_FILENO和STDERR_FILENO以提高可读性。  
标准I/O预定义3个流，他们可以自动地为进程所使用：标准输入/标准输出/标准错误输出。  
  
函数lseek：每个打开文件都有一个与其相关联的“当前文件偏移量”。它通常是一个非负整数，用以度量从文件开始处计算的字节数。  
文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写加长该文件，并在文件中构成一个空洞，这一点是允许的。位于文件中但没有写过的字节都被读为0。  
文件中的空洞并不要求在磁盘上占用存储区。具体处理方式与文件系统的实现有关，当定位到超过文件尾端之后写时，对于新写的数据需要分配磁盘块，但是对于原文件尾端和新开始写位置之间的部分则不需要分配磁盘块。  
  
  
I/O的效率  
大多数文件系统为改善性能都采用某种预读（read ahead）技术。当检测到正进行顺序读取时，系统就试图读入比应用所要求的更多数据，并假想应用很快就会读这些数据。  
操作系统试图用告诉缓存技术将相关文件放置在主存中，所以如若重复度量程序性能，那么后续运行该程序所得到的计时很可能好于第一次。原因是，第一次运行使得文件进入系统高速缓存，后续各次运行一般从系统高速缓存访问文件，无需读、写磁盘。  
Cache的预读与换出，缺页时换出  
  
两个进程同时对同一文件进行追加写操作，可能因为“先定位到文件尾端，然后写”单只出现某一进程的写被覆盖，从而出现错误，其解决办法是使这两个操作对于其他进程而言成为一个原子操作。任何要求多于一个函数调用的操作都不是原子操作，因为在两个函数调用之间，内核有可能会临时挂起进程。  
原子操作要放在一起对其他进程而言是原子的，因为在两个函数调用之间，内核有可能会临时挂起进程。  
多个进程对同一文件进行追加写操作和创建同一个文件时，为防止出错，需满足原子操作。  
  
函数sync、fsync和fdatasync  
传统UNIX系统实现在内核中设有缓冲区高速缓存或页面高速缓存，大多数磁盘I/O都通过缓冲区进行。当我们向文件写入数据时，内核通过先将数据复制到缓冲区中，然后排入队列，晚些时候在写入磁盘。这种方式被称为延迟写。  
通常内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据块写入磁盘。为保证磁盘上世纪文件系统与缓冲区中内容一致，UNIX系统提供了sync、fsync和fdatasync三个函数。  
sync只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。  
**fsync函数只对由文件描述符fd指定的一个文件起作用，并且等待写磁盘操作结束才返回。**fsync可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。  
fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync换回同步更新文件的属性。  
  
标准I/O与文件I/O：  
http://blog.csdn.net/myintelex/article/details/53888324  
I/O模型	文件I/O	标准I/O  
缓冲方式	非缓冲I/O	缓冲I/O  
操作对象	文件描述符	流(FILE )  
打开	open()	fopen()/freopen()/fdopen()  
读	read()	fread()/fgetc()/fgets()…  
写	write()	fwrite()/fputc()/fputs()…  
定位	lseek()	fseek()/ftell()/rewind()/fsetpos()/fgetpos()  
关闭	close()	fclose()  



网络IO：  
http://blog.csdn.net/qq_30154277/article/details/51981821  
网络HttpURLConnection 类  
java的BIO类InputStreamReader、等  
  
  
Linux 网络 I/O 模型简介：  
http://blog.csdn.net/anxpp/article/details/51503329  
Linux 的内核将所有外部设备都看做一个文件来操作（一切皆文件），对一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor（fd，文件描述符）。
而对一个socket的读写也会有响应的描述符，称为socket fd（socket文件描述符），描述符就是一个数字，指向内核中的一个结构体（文件路径，数据区等一些属性）。  
  
根据UNIX网络编程对I/O模型的分类，UNIX提供了5种I/O模型。  
1、阻塞I/O模型  
2、非阻塞I/O模型  
3、I/O复用模型  
Linux提供select/poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样，select/poll可以帮我们侦测多个fd是否处于就绪状态。  
    select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约。  
    Linux还提供一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback。数量没有限制  
4、信号驱动I/O模型  
5、异步I/O  
告知内核启动某个操作，并让内核在整个操作完成后（包括数据的复制）通知进程。  
    信号驱动I/O模型通知的是何时可以开始一个I/O操作，异步I/O模型有内核通知I/O操作何时已经完成。  




## I/O多路复用技术
I/O编程中，需要处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理。  
    正如前面的简介，I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。  
    与传统的多线程模型相比，I/O多路复用的最大优势就是系统开销小，系统不需要创建新的额外线程，也不需要维护这些线程的运行，降低了系统的维护工作量，节省了系统资源。  
    主要的应用场景：  
    服务器需要同时处理多个处于监听状态或多个连接状态的套接字。  
    服务器需要同时处理多种网络协议的套接字。  
  
支持I/O多路复用的系统调用主要有select、pselect、poll、epoll。  
    而当前推荐使用的是epoll，优势如下：  
    支持一个进程打开的socket fd不受限制。  
    I/O效率不会随着fd数目的增加而线性下将。  
    使用mmap加速内核与用户空间的数据传递。  
    epoll拥有更加简单的API。  
  


## I/O模型：同步I/O和异步I/O，阻塞I/O和非阻塞I/O
http://blog.csdn.net/shenlei19911210/article/details/49305413  
blocking IO的特点就是在IO执行的两个阶段（等待数据准备就绪和拷贝数据两个阶段）都被block了。  
在非阻塞式IO中，用户进程其实是需要不断的主动询问kernel数据准备好了没有。  
在多路复用模型中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。因此select()与非阻塞IO类似。  
异步IO是真正非阻塞的，它不会对请求进程产生任何的阻塞，因此对高并发的网络服务器实现至关重要。  
  
异步IO和非阻塞IO的区别！！！  
异步IO就是把IO操作提交给系统，让系统帮我们完成相关操作，操作完成后系统在以某种方式通知我们操作已经完成。非阻塞IO就是我们要通过某种不定时方式向系统询问我们能够开始执行某个IO操作，当得到许可指令后，具体的操作还是需要我们自己动手来完成的！  
  
  
  
  
文件IO、网络IO  
BIO、NIO、AIO  
  
网络IO分为：BIO、NIO、AIO  
BIO和NIO中都有文件IO  
  
  
IO线程模型一直在演化，  
1、由最开始的单线程模型，  
2、到BIO方式的单线程接受请求线程池线程单个线程处理单个请求的读写事件，  
3、再到NIO的单线程接受请求线程池里面的单个线程可以处理不同请求的读写事件，  
4、还有个Leader-follower线程模型，其的出现是为了解决单线程接受请求线程池线程处理请求下线程上下文切换以及线程间通信数据拷贝的开销，并且不需要维护一个队列。  
LeaderFollower线程上下文切换以及线程间通信数据拷贝的开销，直接在IO线程处理请求。  
https://blog.csdn.net/goldlevi/article/details/7705180  
  
  
Reactor和Proactor：  
http://blog.jobbole.com/59676/  
Reactor：实现同步非阻塞IO，多路复用IO  
Proactor：实现异步非阻塞，AIO  
  
  
阻塞IO：阻塞着等待可读和读阻塞  
非阻塞IO：只有读阻塞，准备数据时候非阻塞，也就是没有读等待的阻塞  
IO复用模型：IO复用，默认是同步阻塞，可以设置为非阻塞  
信号驱动IO：非阻塞  
异步IO：异步非阻塞IO  


先有阻塞和非阻塞之分，阻塞的一定是同步的，非阻塞的要根据后续判断，主动询问就是同步，回调和通知的方式就是异步。
  
  
是同步还是异步，关注的是任务完成时消息通知的方式。由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。  
消息的三种通知机制：状态、通知和回调。前者低效，后两者高效、类似。  
  
阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。  
同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。  
  
1、对于同步调用来说，很多时候当前线程可能还是激活的，只是从逻辑上当前函数没有返回而已，此时，这个线程可能也会处理其他的消息。还有一点，在这里先扩展下：  
(a) 如果这个线程在等待当前函数返回时，仍在执行其他消息处理，那这种情况就叫做同步非阻塞；  
(b) 如果这个线程在等待当前函数返回时，没有执行其他消息处理，而是处于挂起等待状态，那这种情况就叫做同步阻塞；  
所以同步的实现方式会有两种：同步阻塞、同步非阻塞；同理，异步也会有两种实现：异步阻塞、异步非阻塞；  
  
2、对于阻塞调用来说，则当前线程就会被挂起等待当前函数返回；  
虽然表面上看非阻塞的方式可以明显的提高CPU的利用率，但是也带了另外一种后果就是系统的线程切换增加。增加的CPU执行时间能不能补偿系统的切换成本需要好好评估。  
  
  
## EPOLL事件有两种模型
Level Triggered (LT)  
Edge Triggered (ET)  
  
LT：在LT模式下，无论fd是否有事件发生，或者还有一些事件没有处理完，每次调用epoll_wait时，总会得到该fd让你处理（只要有没事件没有处理，会一直通知你处理，直到你处理完为止，这样就保证了数据的不丢失）。  
ET:在ET模式下，当有事件发生时，系统只会通知你一次，即在调用epoll_wait返回fd后，不管这个事件你处理还是没处理，处理完没有处理完，当再次调用epoll_wait时，都不会再返回该fd  
  
操作系统在LT模式下维护的就绪队列大小相对于ET模式肯定大，且LT轮询所有的fd总比ET轮询的fd大。自然在性能上LT不如ET，但是在使用ET模式的时，需要循环调用recv,send等处理函数，得保证其事件处理完毕，这样也会带来开销且容易出错。  
从 kernel 代码来看，ET/LT模式的处理逻辑几乎完全相同，差别仅在于 LT模式在 event 发生时不会将其从 ready list 中移除，略为增大了event 处理过程中 kernel space 中记录数据的大小。  
           
  
  
  
## 用户空间与内核空间
现在操作系统都是采用虚拟存储器，对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。  
操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。  
为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。  
针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。  
  
进程切换  
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换/任务切换/上下文切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。  
从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：  
1、保存处理机上下文，包括程序计数器和其他寄存器。  
2、更新PCB信息。  
3、把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。  
4、选择另一个进程执行，并更新其PCB。  
5、更新内存管理的数据结构。  
6、恢复处理机上下文。  
           
进程的阻塞  
正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。  
  
文件描述符fd  
文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。  
文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。  
  
缓存 IO  
缓存 IO 又被称作标准 IO，大多数文件系统的默认 IO 操作都是缓存 IO。在 Linux 的缓存 IO 机制中，操作系统会将 IO 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。  
  
缓存 IO 的缺点：  
数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。  
  
  
  
https://mp.weixin.qq.com/s/KFzhayyAc8RMYMDTuyQXUg      
一.什么是同步？什么是异步？  
二.什么是阻塞？什么是非阻塞？  
三.什么是阻塞IO？什么是非阻塞IO？  
四.什么是同步IO？什么是异步IO？  
五.五种IO模型  
六.两种高性能IO设计模式             
           
1、同步和异步  
同步就是：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；  
异步就是：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。  
java中的synchronized关键字联系起来进行类比。当多个线程同时访问一个变量时，每个线程访问该变量就是一个事件，对于同步来说，就是这些线程必须逐个地来访问该变量，一个线程在访问该变量的过程中，其他线程必须等待；而对于异步来说，就是多个线程不必逐个地访问该变量，可以同时进行访问。  
  
2、阻塞和非阻塞：  
　　阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；  
　　非阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。  
　　这就是阻塞和非阻塞的区别。也就是说阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。  
  
同步和异步着重点在于多个任务的执行过程中，一个任务的执行是否会导致整个流程的暂时等待；  
而阻塞和非阻塞着重点在于发出一个请求操作时，如果进行操作的条件不满足是否会返会一个标志信息告知条件不满足。          
    
3、阻塞IO和非阻塞IO           
通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。  
  
　　当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：  
　　1）查看数据是否就绪；  
　　2）进行数据拷贝（将数据从内核空间拷贝到用户空间）。          
           
阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。  
  
4、同步IO和异步IO模型  
事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的：  
　　对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程。  
　　而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。  
  
同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。  
  
  
5、在《Unix网络编程》一书中提到了五种IO模型，分别是：阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。  
  
6、在传统的网络服务设计模式中，有两种比较经典的模式：  
　　一种是多线程，一种是线程池。  
　　对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件  
  
因此便出现了下面的两种高性能IO设计模式：Reactor和Proactor。  
  
