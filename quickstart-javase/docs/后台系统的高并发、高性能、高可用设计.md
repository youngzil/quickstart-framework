## 后台系统的高并发、高性能、高可用设计
- [如何解决三高](#如何解决三高)
- [缓存](#缓存)
    - [缓存有效原理](#缓存有效原理)
    - [缓存分类](#缓存分类)
    - [缓存适用场景](#缓存适用场景)
    - [不适合缓存的场景](#不适合缓存的场景)
    - [更新策略](#更新策略)
- [预处理和延后处理](#预处理和延后处理)
    - [预先处理](#预先处理)
    - [延后处理](#延后处理)
- [池化](#池化)
    - [内存池难点](#内存池难点)
    - [线程池实现上一般有四个核心组成部分](#线程池实现上一般有四个核心组成部分)
    - [连接池](#连接池)
    - [对象池](#对象池)
- [同步变异步](#同步变异步)
- [消息队列](#消息队列)
- [批量处理](#批量处理)
- [数据库](#数据库)
- [IO、CPU](#IO、CPU)
- [时间换空间](#时间换空间)
    - [时间换空间举例](#时间换空间举例)
    - [设计原理](#设计原理)



## 如何解决三高
- 高并发
- 高性能
- 高可用

## 缓存

### 缓存有效原理
缓存本质来说是使用空间换时间的思想

比如 CPU 就自带 L1、L2、L3 Cache

缓存之所以能够大幅提高系统的性能，关键在于数据的访问具有局部性，也就是二八定律：「百分之八十的数据访问是集中在 20% 的数据上」。这部分数据也被叫做热点数据。


### 缓存分类
- 本地缓存Caffeine、Guava
- 分布式缓存
    - Redis
    - Memcache


### 缓存适用场景
- 读多写少
- 计算耗时大，且实时性不高


### 不适合缓存的场景
- 写多读少，频繁更新
- 对数据一致性要求严格
- 数据访问完全随机，导致缓存的命中率极低


### 更新策略
- Cache-Aside  
这应该是最容易想到的模式了，获取数据时先从缓存读，如果 cache hit 则直接返回，没命中就从数据源获取，然后更新缓存  
写数据的时候则先更新数据源，然后设置缓存失效，下一次获取数据的时候必然 cache miss，然后触发回源。

- Cache-As-SoR  
从字面上来看，就是把 Cache 当作 SoR，也就是数据源，所以一切读写操作都是针对 Cache 的，由 Cache 内部自己维护和数据源的一致性。
    - Read Through：这种方式和 Cache-Aside 非常相似，都是在查询时发生 cache miss 去更新缓存，但是区别在于 Cache-Aside 需要调用方手动更新缓存，而 Cache-As-SoR 则是由缓存内部实现自己负责，对应用层透明。
    - Write Through： 直写式，就是在将数据写入缓存的同时，缓存也去更新后面的数据源，并且必须等到数据源被更新成功后才可返回。这样保证了缓存和数据库里的数据一致性。
    - Write Back：回写式，数据写入缓存即可返回，缓存内部会异步的去更新数据源，这样好处是写操作特别快，因为只需要更新缓存。并且缓存内部可以合并对相同数据项的多次更新，但是带来的问题就是数据不一致，可能发生写丢失。



## 预处理和延后处理
预先延后，这其实是一个事物的两面，不管是预先还是延后核心思想都是将本来该在实时链路上处理的事情剥离，要么提前要么延后处理。

降低实时链路的路径长度，这样能有效提高系统性能。


### 预先处理
- 比如 CPU 基于历史访存信息，将内存中的指令和数据预取到 Cache 中，这样可以大大提高Cache 命中率。  
- 还比如在 Linux 文件系统中，预读算法会预测即将访问的 page，然后批量加载比当前读请求更多的数据缓存在 page cache 中，这样当下次读请求到来时可以直接从 cache 中返回，大大减少了访问磁盘的时间。  


### 延后处理
- 先提醒稍后再看XXX（订单、扣款、到账）
- COW（Copy On Write，写时复制）



## 池化

### 内存池难点
- 如何快速分配内存
- 降低内存碎片率
- 维护内存池所需的额外空间尽量少
- 实现：比如 Google 的 「tcmalloc」 和 Facebook 的 「jemalloc」。


### 线程池实现上一般有四个核心组成部分
- 管理器（Manager）: 用于创建并管理线程池。
- 工作线程（Worker）: 执行任务的线程。
- 任务接口（Task）: 每个具体的任务必须实现任务接口，工作线程将调用该接口来完成具体的任务。
- 任务队列（TaskQueue）: 存放还未执行的任务。


### 连接池
池化实际上是预处理和延后处理的一种应用场景，通过池子将各类资源的创建提前和销毁延后。
HTTP 长链接也算一个变相的链接池，虽然它本质上只有一个连接，但是思想却和连接池不谋而合，都是为了复用同一个连接发送多个 HTTP 请求，避免建立和断开连接的开销。


### 对象池



## 同步变异步  
对于处理耗时的任务，如果采用同步的方式，那么会增加任务耗时，降低系统并发度。  
可以通过将同步任务变为异步进行优化。  

异步编程往往需要回调函数（Callback function），如果回调函数的层级太深，这就是回调地狱（Callback hell）。  
解决：响应式编程  



## 消息队列
- 服务解耦
- 异步处理
- 流量控制
- 削峰填谷

消息队列的核心思想就是把同步的操作变成异步处理，异步处理会带来相应的好处
- 服务解耦
- 提高系统的并发度，将非核心操作异步处理，不会阻塞住主流程

但是软件开发没有银弹，所有的方案选择都是一种 trade-off（权衡）。 同样，异步处理也不全是好处，也会导致一些问题
- 降低了数据一致性，从强一致性变为最终一致性
- 有消息丢失的风险，比如宕机，需要有容灾机制



## 批量处理
- 请求合并
- TCP报文的拆包和黏包
- 通过合并一些频繁请求的小资源可以获得更快的加载速度。
- 批量发送消息、批量更新接口、批量查询



## 数据库
- SQL优化
- 索引优化
    - 主键索引和普通索引，以及它们之间的区别
    - 覆盖索引、联合索引
    - 最左前缀匹配原则
    - 索引下推
- 读写分离
    - 读写分离解决问题的同时也会带来新问题，比如主库和从库数据不一致
- 分库分表
    - 水平拆分
    - 垂直拆分


MySQL 中有两种锁:
- 排它锁( X 锁)： 事务 T 对数据 A 加上 X 锁时，只允许事务 T 读取和修改数据 A。
- 共享锁( S 锁)： 事务 T 对数据 A 加上 S 锁时，其他事务只能再对数据 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。



## IO、CPU
- Zero Copy零拷贝
- IO复用
- 高效序列化与反序列化
- 无锁编程
- 基于硬件提供的原子操作 CAS(Compare And Swap) 
- 多线程
- 缓存友好



## 时间换空间

效率无非是时间换空间、空间换时间的问题，资源的消耗并不会消失，只是转移了，或者使用一种富足的资源去置换稀缺的资源，比如充足的空间换取高效率

所谓的无状态，并不是消除状态，只是状态的转移，可以转移到统一的地方，比如分布式缓存Redis或者持久化的存储介质DB等统一存储

感觉有点类似物理学上的物质守恒或者能量守恒定律


### 时间换空间举例
比如HashMap中的容量和扩容负载因子参数的设计，就是一种时间换空间、空间换时间的问题
数据的索引结构，使用增删改的效率和空间的占用，换取查询效率的提升


### 设计原理
设计就是有些东西可能是往一起聚合，有些是要分散开，要根据具体的业务来处理

比如消除状态，就是聚合状态到一个统一的地方

相反类似把一些服务端不好实现的功能，放在客户端或者SDK中来实现，一方面可以在客户端缓存，另一方面这些执行需要的资源都是在客户端来完成的，其实相当于资源或者消耗的转移和分散

- 比如RocketMQ的Filter机制，上传代码到服务端，在服务端执行符合SQL92语法的过滤代码
- RocketMQ的幂等功能，放在SDK的客户端执行，分散服务器的压力
- RPC框架中的客户端的缓存、负载、路由等，都是分散服务端压力，或者转嫁到客户端的一种方式
- 边缘计算，把一些计算任务放到边缘设备是设备上来执行



### 能量守恒定律
能量守恒定律是自然界普遍的基本定律之一。一般表述为：能量既不会凭空产生，也不会凭空消失，它只会从一种形式转化为另一种形式，或者从一个物体转移到其它物体，而能量的总量保持不变。

### 物质守恒定律
物质守恒定律，就是物质是不会消失也不会产生的，只能由一种物质转化成另一种物质。物质守恒定律里说到:物质不会凭空产生,只是从一形态转换成另一种形态了。

### 质能守恒定律
质能守恒定律是质量守恒定律与能量守恒定律的总称，主要是指在一个孤立系统内所有粒子的相对论静能与动能之和在相互作用过程中保持不变。质能守恒定律充分反映了物质和运动的统一性。

可用以下质能方程公式表示：E=mc²，E表示能量，m代表质量，光速c=299792.458km/s (一般取300000km/s）。

E = mc²（即质能守恒，亦称为质能转换公式、质能方程）是一种阐述能量（E）与质量（m）间相互关系的理论物理学公式，公式中的 c 是物理学中代表光速的常数。





[后台高性能、高并发设计指南](https://zhuanlan.zhihu.com/p/322464806)  


