设计模式的六大原则
设计模式：23种
创建型模式设计模式详解
结构型设计模式详解
行为型设计模式详解



---------------------------------------------------------------------------------------------------------------------
设计模式：23种

工厂方法模式：一个抽象工厂，一个抽象产品，只是一个返回实际类型的方法。
抽象工厂模式：一个抽象工厂，多个抽象产品，该模式可以与策略模式结合使用。
单例模式：私有构造方法，保证只有一个实例化对象，用来确保类只有一个实例。Joshua Bloch在Effetive Java中建议到，还有一种方法就是使用枚举。
建造者模式：builder构建对象，fluent 接口(链式调用的接口)，用于通过定义一个类来简化复杂对象的创建，该类的目的是构建另一个类的实例。构建器模式还允许实现Fluent接口。
原型模式：implements Cloneable，clone出一个产品，使得类的实例能够生成自身的拷贝。如果创建一个对象的实例非常复杂且耗时时，就可以使用这种模式，而不重新创建一个新的实例，你可以拷贝一个对象并直接修改它。


适配器模式：一个类型转为另一个类型，常用于将一个新接口适配旧接口
装饰者模式：装饰着持有被装饰者对象，动态的给一个对象附加额外的功能，因此它也是子类化的一种替代方法。
代理模式：没有看出来和装饰者有什么区别，代理模式用于向较简单的对象代替创建复杂或耗时的对象。
外观模式：降低了类类之间的耦合度，有一个中间类持有其他全部类，只需要跟中间类打交道即可，为一组组件，接口，抽象或子系统提供简化的接口。
桥接模式：将抽象化与实现化解耦，使得二者可以独立变化，感觉是装饰者的升级，根据方法可以改变被装饰者，可以改变是实现，将抽象和抽象的具体实现进行解耦，这样可以使得抽象和抽象的具体实现可以独立进行变化。
组合模式：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等，让客户端看起来在处理单个对象和对象的组合是平等的，换句话说，某个类型的方法同时也接受自身类型作为参数。
享元模式：实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。如连接池，使用缓存来减少对小对象的访问时间


策略模式：根据参数不同，选择不同的实现
模板方法模式：抽象类定义好流程模板，由子类去做模版中每一个流程的实现

观察者模式：被观察者可以新增、删除观察者，当被观察者有变化时候，轮询通知观察者
迭代子模式：迭代器模式就是顺序访问聚集中的对象，集合中非常常见，包含：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。提供一个统一的方式来访问集合中的对象。
责任链模式：责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。通过把请求从一个对象传递到链条中下一个对象的方式来解除对象之间的耦合，直到请求被处理完毕。链中的对象是同一接口或抽象类的不同实现。
命令模式：根据不同的命令类，来做出不同的执行，将命令包装在对象中，以便可以将其存储，传递到方法中，并像任何其他对象一样返回。

备忘录模式：备份使用，主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，例如假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作，生成对象状态的一个快照，以便对象可以恢复原始状态而不用暴露自身的内容。比如Date对象通过自身内部的一个long值来实现备忘录模式。
状态模式：核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。，允许您在运行时根据内部状态轻松更改对象的行为。

访问者模式：访问者持有不同的对象，执行不同的行为，通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。
中介者模式：中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。
解释器模式：不同的实现类，持有相同的对象，但是行为不同，因为实现类不同，此模式通常描述为该语言定义语法并使用该语法来解释该格式的语句。

![http连接过程图片](../../quickstart-document/doc/interview/image/design-pattern-relation.png "ReferencePicture")



---------------------------------------------------------------------------------------------------------------------
设计模式
https://www.gitbook.com/book/quanke/design-pattern-java/details


参考文章
http://blog.csdn.net/qq3965470/article/details/52167228
https://www.cnblogs.com/tongkey/p/7170826.html
http://blog.csdn.net/jason0539/article/details/44956775

https://www.cnblogs.com/jasongj/p/5551722.html



http://blog.csdn.net/jason0539/article/details/44956775
创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
结构型模式：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式
行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
还有两类：并发型模式和线程池模式。

创建型模式：Factory Method、Abstract Factory、Singleton、Builder、Prototype
结构型模式：Adapter、Decorator、Proxy、Facade、Bridge、Composite、Flyweight
行为型模式：Strategy、Template Method、Observer、Iterator、Chain of Responsibility、Command、Memento、State、Visitor、Mediator、Interpreter

Interpreter：java的接口多态

---------------------------------------------------------------------------------------------------------------------

创建型模式设计模式详解
创建型模式：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
创建型模式：Factory Method、Abstract Factory、Singleton、Builder、Prototype



简单工厂模式（Simple Factory）（简单工厂模式不属于23中涉及模式，简单工厂一般分为：普通简单工厂、多方法简单工厂、静态方法简单工厂）
工厂方法模式（Factory Method）
抽象工厂模式（Abstract Factory）

工厂方法模式：一个抽象工厂，一个抽象产品，每个抽象产品派生多个具体产品，每个抽象工厂派生多个具体工厂，每个工厂类只生产一种产品
抽象工厂模式：一个抽象工厂，多个抽象产品，每个抽象产品派生多个具体产品，每个抽象工厂派生多个具体工厂，每个工厂类可以生产多种产品

接口、工厂类：生产具体的产品类


java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。
　　单例模式有以下特点：
　　1、单例类只能有一个实例。
　　2、单例类必须自己创建自己的唯一实例。
　　3、单例类必须给所有其他对象提供这一实例。
　　单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。

单例条件：
私有化构造方法
1、静态内部变量
2、静态内部类
3、volatile + Double-Check



定义：
建造者模式：将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

实用范围
1、当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。
2、当构造过程必须允许被构造的对象有不同表示时。

角色
在这样的设计模式中，有以下几个角色：
1、Builder：为创建一个产品对象的各个部件指定抽象接口。
2、ConcreteBuilder：实现Builder的接口以构造和装配该产品的各个部件，定义并明确它所创建的表示，并提供一个检索产品的接口。
3、Director：构造一个使用Builder接口的对象，指导构建过程。
4、Product：表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括将这些部件装配成最终产品的接口。



使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明显。
使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。
因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。


原型模式的注意事项：implements Cloneable
1、使用原型模式复制对象不会调用类的构造方法。因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意。
2、深拷贝与浅拷贝。Object类的clone方法只会拷贝对象中的基本的数据类型（8种基本数据类型byte,char,short,int,long,float,double，boolean），对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。


---------------------------------------------------------------------------------------------------------------------

结构型设计模式详解
结构型模式：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式
结构型模式：Adapter、Decorator、Proxy、Facade、Bridge、Composite、Flyweight


适配器模式：已经存在的类或api不符合标准，新建适配器类implements标准接口，extends 老的实现类


装饰者模式：持有装饰的对象，并且会添加自己的一些装饰行为


代理模式：持有被代理的对象
动态代理：JDK动态代理、CGLIB（可以使用jdk动态代理，也可以使用基于asm修改字节码的实现）
静态代理：JDK代理设计模式、Javassist
cglib和Jdk动态代理的区别
目前字节码修改框架：ASM、Javassist、AspectJ（编译器级别）


外观模式：有一种门面模式的意思，有一个外观类包含多个局部的类，如Computer的start调用CPU、Disk、Memory的start

桥接模式：交接类可以设置不同的被桥接的类，改变被桥接的类，就表现不同的行为，类似动态代理的味道


组合模式:比如tree的节点TreeNode，有种外观模式的意思


享元模式：共享数据、对象等，池的概念，比如连接池，线程池、对象池等


---------------------------------------------------------------------------------------------------------------------


行为型设计模式详解
行为型模式：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式
行为型模式：Strategy、Template Method、Observer、Iterator、Chain of Responsibility、Command、Memento、State、Visitor、Mediator、Interpreter


策略模式：根据输入的参数、注入的对象不同，同一个方法采取不同的行为

模板方法模式：分类定义好类的行为、流程等，有子类实现具体的抽象方法，具体的流程行为



观察者模式：观察者注入被观察者，被观察者变化后，通知观察者

迭代子模式：迭代模式，java iterator迭代方式遍历集合等

责任链模式：链式调用，比如审批金额的流程，netty的请求处理流程

命令模式：根据不同的命令，执行不同的命令类，不同的命令类调用命令接受者的不同的方法



备忘录模式：保存备份对象的属性、信息等

状态模式：根据不同的状态做出不同的行为



访问者模式：通过访问者持有对象本身，通过调用访问者，访问者反过来调用本类的方法

中介者模式：通过调用中介者对象，中介者调用实际的对象

解释器模式：不同的对象对于相同的输入有不同的解释行为




---------------------------------------------------------------------------------------------------------------------


责任链模式：
web的filter，项目审批模式（低于1000就1个人审批，大于1000转给下一个人继续审批）


策略模式
如RocketMQ提供的CLI监控接口，Broker服务端的不同的Processor


---------------------------------------------------------------------------------------------------------------------
https://www.jianshu.com/p/807bc228dbc2
https://juejin.im/post/5a52144d6fb9a01c9b65c651


单个类的：单一职责、接口隔离
类接口和子类：里式替换、依赖倒置
迪米特法则、开闭原则


总原则－开闭原则：对扩展开放，对修改封闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。

1、单一职责原则（Single Responsibility Principle，简称SRP ）
核心思想：应该有且仅有一个原因引起类的变更
定义：就一个类而言， 应该仅有一个引起它变化的原因。

2、里氏替换原则（Liskov Substitution Principle,简称LSP）
核心思想：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。
定义：所有引用基类的地方必须能透明地使用其子类的对象。

3、依赖倒置原则（Dependence Inversion Principle,简称DIP）
核心思想：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象；
定义：高层模块不应该依赖于低层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。

4、接口隔离原则（Interface Segregation Principle,简称ISP）
核心思想：类间的依赖关系应该建立在最小的接口上
定义：一个类对另一个类的依赖应该建立在最小的接口上。

5、迪米特法则（Law of Demeter,简称LoD）
核心思想：类间解耦。一个类应该对自己需要耦合或者调用的类知道最少
定义：一个软件实体应当尽可能少地与其他实体发生相互作用。

6、开放封闭原则（Open Close Principle,简称OCP）
核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化
定义：类、模块、函数等应该是可以拓展的，但是不可修改。


一句话概括:单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。




设计模式的六大原则：
1、单一职责原则：不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。
2、里氏替换原则（Liskov Substitution Principle）：任何基类可以出现的地方，子类一定可以出现。里氏替换原则是继承复用的基石，
3、依赖倒转原则（Dependence Inversion Principle）：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。
4、接口隔离原则（Interface Segregation Principle）：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。
5、迪米特法则（最少知道原则）（Demeter Principle）：一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。
6、开放封闭原则（Open Close Principle,简称OCP）
核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化
定义：类、模块、函数等应该是可以拓展的，但是不可修改。


---------------------------------------------------------------------------------------------------------------------







