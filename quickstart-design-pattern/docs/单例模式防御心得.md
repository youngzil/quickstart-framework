1、singleton模式四种线程安全的实现
2、单例模式防御心得:克隆、序列化、反射




---------------------------------------------------------------------------------------------------------------------


singleton模式四种线程安全的实现

1).Eager initialization 饿汉式单例类(依赖jvm在加载类时创建唯一单例实例)：EagerSingleton.java
2)Lazy initialization 懒汉式单例类 LazySingleton.java
3)"双检锁"(Double-Checked Lock)尽量将"加锁"推迟,只在需要时"加锁"(仅适用于java 5.0 以上版本,volatile保证原子操作)   DoubleCheckedLockingSingleton.java
4)Lazy initialization holder class 满足所有 Double-Checked Locking 满足的条件，并且没有显示的同步操作    LazyInitHolderSingleton.java


参考  
https://blog.csdn.net/u013256816/article/details/50427061  

---------------------------------------------------------------------------------------------------------------------

单例模式防御心得:克隆、序列化、反射



克隆，当你的单例类需要继承Cloneable接口时，就可以通过clone方法获取一个新的对象，那么单例防御失败。
同理，序列化也可以，或者用反射，也可以。




//获取构造函数
Constructor constructor = SingleTon.class.getDeclaredConstructor();
constructor.setAccessible(true);





一，抵御clone攻击：
首先给测试的类实现Cloneable接口，重写克隆方法：

/**
 * 防止克隆攻击
 * @return
* @throws CloneNotSupportedException
 */
@Override
protected Object clone() throws CloneNotSupportedException {
    return getInstance();
}




二，抵御序列化攻击
给测试类实现Serializable接口，然后重写一个方法：

/**
 * 防止序列化攻击
 * @return
*/
private Object readResolve() {
    return getInstance();
}




三，抵御反射
1、这里的思路就是加一个flag，判断构造函数是否第一次被调用。
    变形：加一个静态变量Count，计算构造函数调用的次数
2、枚举





参考
https://zhuanlan.zhihu.com/p/28491630
https://blog.csdn.net/u013256816/article/details/50525335


